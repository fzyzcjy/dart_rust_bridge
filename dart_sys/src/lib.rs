#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(unused_variables)]
#![allow(dead_code)]

mod tests;

/* automatically generated by rust-bindgen */

pub const ILLEGAL_PORT: i64 = 0;
pub const _SAL_VERSION: u32 = 20;
pub const __SAL_H_VERSION: u32 = 180000000;
pub const _USE_DECLSPECS_FOR_SAL: u32 = 0;
pub const _USE_ATTRIBUTES_FOR_SAL: u32 = 0;
pub const _CRT_PACKING: u32 = 8;
pub const _HAS_EXCEPTIONS: u32 = 1;
pub const _HAS_CXX17: u32 = 0;
pub const _HAS_CXX20: u32 = 0;
pub const _HAS_NODISCARD: u32 = 0;
pub const _ARGMAX: u32 = 100;
pub const _CRT_INT_MAX: u32 = 2147483647;
pub const _CRT_FUNCTIONS_REQUIRED: u32 = 1;
pub const _CRT_HAS_CXX17: u32 = 0;
pub const _ARM_WINAPI_PARTITION_DESKTOP_SDK_AVAILABLE: u32 = 1;
pub const _CRT_BUILD_DESKTOP_APP: u32 = 1;
pub const _CRT_INTERNAL_NONSTDC_NAMES: u32 = 1;
pub const __STDC_SECURE_LIB__: u32 = 200411;
pub const __GOT_SECURE_LIB__: u32 = 200411;
pub const __STDC_WANT_SECURE_LIB__: u32 = 1;
pub const _SECURECRT_FILL_BUFFER_PATTERN: u32 = 254;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_COUNT: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES: u32 = 1;
pub const _CRT_SECURE_CPP_OVERLOAD_STANDARD_NAMES_MEMORY: u32 = 0;
pub const _CRT_SECURE_CPP_OVERLOAD_SECURE_NAMES_MEMORY: u32 = 0;
pub const WCHAR_MIN: u32 = 0;
pub const WCHAR_MAX: u32 = 65535;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 65535;
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIdFAST16: &[u8; 2usize] = b"d\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIdMAX: &[u8; 4usize] = b"lld\0";
pub const PRIdPTR: &[u8; 4usize] = b"lld\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIiFAST16: &[u8; 2usize] = b"i\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIiMAX: &[u8; 4usize] = b"lli\0";
pub const PRIiPTR: &[u8; 4usize] = b"lli\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIoFAST16: &[u8; 2usize] = b"o\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIoMAX: &[u8; 4usize] = b"llo\0";
pub const PRIoPTR: &[u8; 4usize] = b"llo\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIuFAST16: &[u8; 2usize] = b"u\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIuMAX: &[u8; 4usize] = b"llu\0";
pub const PRIuPTR: &[u8; 4usize] = b"llu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIxFAST16: &[u8; 2usize] = b"x\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIxMAX: &[u8; 4usize] = b"llx\0";
pub const PRIxPTR: &[u8; 4usize] = b"llx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIXFAST16: &[u8; 2usize] = b"X\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIXMAX: &[u8; 4usize] = b"llX\0";
pub const PRIXPTR: &[u8; 4usize] = b"llX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNdFAST16: &[u8; 2usize] = b"d\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNdMAX: &[u8; 4usize] = b"lld\0";
pub const SCNdPTR: &[u8; 4usize] = b"lld\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNiFAST16: &[u8; 2usize] = b"i\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNiMAX: &[u8; 4usize] = b"lli\0";
pub const SCNiPTR: &[u8; 4usize] = b"lli\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNoFAST16: &[u8; 2usize] = b"o\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNoMAX: &[u8; 4usize] = b"llo\0";
pub const SCNoPTR: &[u8; 4usize] = b"llo\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNuFAST16: &[u8; 2usize] = b"u\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNuMAX: &[u8; 4usize] = b"llu\0";
pub const SCNuPTR: &[u8; 4usize] = b"llu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNxFAST16: &[u8; 2usize] = b"x\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNxMAX: &[u8; 4usize] = b"llx\0";
pub const SCNxPTR: &[u8; 4usize] = b"llx\0";
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const DART_FLAGS_CURRENT_VERSION: u32 = 11;
pub const DART_INITIALIZE_PARAMS_CURRENT_VERSION: u32 = 4;
pub const DART_KERNEL_ISOLATE_NAME: &[u8; 15usize] = b"kernel-service\0";
pub const DART_VM_SERVICE_ISOLATE_NAME: &[u8; 11usize] = b"vm-service\0";
pub const kVmSnapshotDataCSymbol: &[u8; 21usize] = b"_kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsCSymbol: &[u8; 29usize] = b"_kDartVmSnapshotInstructions\0";
pub const kIsolateSnapshotDataCSymbol: &[u8; 26usize] = b"_kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsCSymbol: &[u8; 34usize] =
    b"_kDartIsolateSnapshotInstructions\0";
pub const kVmSnapshotDataAsmSymbol: &[u8; 21usize] = b"_kDartVmSnapshotData\0";
pub const kVmSnapshotInstructionsAsmSymbol: &[u8; 29usize] = b"_kDartVmSnapshotInstructions\0";
pub const kIsolateSnapshotDataAsmSymbol: &[u8; 26usize] = b"_kDartIsolateSnapshotData\0";
pub const kIsolateSnapshotInstructionsAsmSymbol: &[u8; 34usize] =
    b"_kDartIsolateSnapshotInstructions\0";
pub const DART_EMBEDDER_INFORMATION_CURRENT_VERSION: u32 = 1;
pub const DART_TIMELINE_STREAM_API: u32 = 1;
pub const DART_TIMELINE_STREAM_COMPILER: u32 = 2;
pub const DART_TIMELINE_STREAM_DART: u32 = 4;
pub const DART_TIMELINE_STREAM_DEBUGGER: u32 = 8;
pub const DART_TIMELINE_STREAM_EMBEDDER: u32 = 16;
pub const DART_TIMELINE_STREAM_GC: u32 = 32;
pub const DART_TIMELINE_STREAM_ISOLATE: u32 = 64;
pub const DART_TIMELINE_STREAM_VM: u32 = 128;
pub const DART_TIMELINE_STREAM_ALL: u32 = 255;
pub const DART_TIMELINE_STREAM_DISABLE: u32 = 0;

pub type va_list = *mut ::std::os::raw::c_char;

extern "C" {
    pub fn __va_start(arg1: *mut *mut ::std::os::raw::c_char, ...);
}

pub type wchar_t = ::std::os::raw::c_ushort;

extern "C" {
    pub fn __security_init_cookie();
}

extern "C" {
    pub fn __security_check_cookie(_StackCookie: usize);
}

extern "C" {
    pub fn __report_gsfailure(_StackCookie: usize);
}

extern "C" {
    pub static mut __security_cookie: usize;
}

pub type __crt_bool = bool;

extern "C" {
    pub fn _invalid_parameter_noinfo();
}

extern "C" {
    pub fn _invalid_parameter_noinfo_noreturn();
}

extern "C" {
    pub fn _invoke_watson(
        _Expression: *const wchar_t,
        _FunctionName: *const wchar_t,
        _FileName: *const wchar_t,
        _LineNo: ::std::os::raw::c_uint,
        _Reserved: usize,
    );
}

pub type errno_t = ::std::os::raw::c_int;
pub type wint_t = ::std::os::raw::c_ushort;
pub type wctype_t = ::std::os::raw::c_ushort;
pub type __time32_t = ::std::os::raw::c_long;
pub type __time64_t = ::std::os::raw::c_longlong;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data_public {
    pub _locale_pctype: *const ::std::os::raw::c_ushort,
    pub _locale_mb_cur_max: ::std::os::raw::c_int,
    pub _locale_lc_codepage: ::std::os::raw::c_uint,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_pointers {
    pub locinfo: *mut __crt_locale_data,
    pub mbcinfo: *mut __crt_multibyte_data,
}

pub type _locale_t = *mut __crt_locale_pointers;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Mbstatet {
    pub _Wchar: ::std::os::raw::c_ulong,
    pub _Byte: ::std::os::raw::c_ushort,
    pub _State: ::std::os::raw::c_ushort,
}

pub type mbstate_t = _Mbstatet;
pub type time_t = __time64_t;
pub type rsize_t = usize;

extern "C" {
    pub fn _wassert(_Message: *const wchar_t, _File: *const wchar_t, _Line: ::std::os::raw::c_uint);
}

pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Lldiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}

pub type imaxdiv_t = _Lldiv_t;

extern "C" {
    pub fn imaxabs(_Number: intmax_t) -> intmax_t;
}

extern "C" {
    pub fn imaxdiv(_Numerator: intmax_t, _Denominator: intmax_t) -> imaxdiv_t;
}

extern "C" {
    pub fn strtoimax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}

extern "C" {
    pub fn _strtoimax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}

extern "C" {
    pub fn strtoumax(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}

extern "C" {
    pub fn _strtoumax_l(
        _String: *const ::std::os::raw::c_char,
        _EndPtr: *mut *mut ::std::os::raw::c_char,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}

extern "C" {
    pub fn wcstoimax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> intmax_t;
}

extern "C" {
    pub fn _wcstoimax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> intmax_t;
}

extern "C" {
    pub fn wcstoumax(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
    ) -> uintmax_t;
}

extern "C" {
    pub fn _wcstoumax_l(
        _String: *const wchar_t,
        _EndPtr: *mut *mut wchar_t,
        _Radix: ::std::os::raw::c_int,
        _Locale: _locale_t,
    ) -> uintmax_t;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Isolate {
    _unused: [u8; 0],
}

#[doc = " An isolate is the unit of concurrency in Dart. Each isolate has"]
#[doc = " its own memory and thread of control. No state is shared between"]
#[doc = " isolates. Instead, isolates communicate by message passing."]
#[doc = ""]
#[doc = " Each thread keeps track of its current isolate, which is the"]
#[doc = " isolate which is ready to execute on the current thread. The"]
#[doc = " current isolate may be NULL, in which case no isolate is ready to"]
#[doc = " execute. Most of the Dart apis require there to be a current"]
#[doc = " isolate in order to function without error. The current isolate is"]
#[doc = " set by any call to Dart_CreateIsolateGroup or Dart_EnterIsolate."]
pub type Dart_Isolate = *mut _Dart_Isolate;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_Handle {
    _unused: [u8; 0],
}

#[doc = " An object reference managed by the Dart VM garbage collector."]
#[doc = ""]
#[doc = " Because the garbage collector may move objects, it is unsafe to"]
#[doc = " refer to objects directly. Instead, we refer to objects through"]
#[doc = " handles, which are known to the garbage collector and updated"]
#[doc = " automatically when the object is moved. Handles should be passed"]
#[doc = " by value (except in cases like out-parameters) and should never be"]
#[doc = " allocated on the heap."]
#[doc = ""]
#[doc = " Most functions in the Dart Embedding API return a handle. When a"]
#[doc = " function completes normally, this will be a valid handle to an"]
#[doc = " object in the Dart VM heap. This handle may represent the result of"]
#[doc = " the operation or it may be a special valid handle used merely to"]
#[doc = " indicate successful completion. Note that a valid handle may in"]
#[doc = " some cases refer to the null object."]
#[doc = ""]
#[doc = " --- Error handles ---"]
#[doc = ""]
#[doc = " When a function encounters a problem that prevents it from"]
#[doc = " completing normally, it returns an error handle (See Dart_IsError)."]
#[doc = " An error handle has an associated error message that gives more"]
#[doc = " details about the problem (See Dart_GetError)."]
#[doc = ""]
#[doc = " There are four kinds of error handles that can be produced,"]
#[doc = " depending on what goes wrong:"]
#[doc = ""]
#[doc = " - Api error handles are produced when an api function is misused."]
#[doc = "   This happens when a Dart embedding api function is called with"]
#[doc = "   invalid arguments or in an invalid context."]
#[doc = ""]
#[doc = " - Unhandled exception error handles are produced when, during the"]
#[doc = "   execution of Dart code, an exception is thrown but not caught."]
#[doc = "   Prototypically this would occur during a call to Dart_Invoke, but"]
#[doc = "   it can occur in any function which triggers the execution of Dart"]
#[doc = "   code (for example, Dart_ToString)."]
#[doc = ""]
#[doc = "   An unhandled exception error provides access to an exception and"]
#[doc = "   stacktrace via the functions Dart_ErrorGetException and"]
#[doc = "   Dart_ErrorGetStackTrace."]
#[doc = ""]
#[doc = " - Compilation error handles are produced when, during the execution"]
#[doc = "   of Dart code, a compile-time error occurs.  As above, this can"]
#[doc = "   occur in any function which triggers the execution of Dart code."]
#[doc = ""]
#[doc = " - Fatal error handles are produced when the system wants to shut"]
#[doc = "   down the current isolate."]
#[doc = ""]
#[doc = " --- Propagating errors ---"]
#[doc = ""]
#[doc = " When an error handle is returned from the top level invocation of"]
#[doc = " Dart code in a program, the embedder must handle the error as they"]
#[doc = " see fit.  Often, the embedder will print the error message produced"]
#[doc = " by Dart_Error and exit the program."]
#[doc = ""]
#[doc = " When an error is returned while in the body of a native function,"]
#[doc = " it can be propagated up the call stack by calling"]
#[doc = " Dart_PropagateError, Dart_SetReturnValue, or Dart_ThrowException."]
#[doc = " Errors should be propagated unless there is a specific reason not"]
#[doc = " to.  If an error is not propagated then it is ignored.  For"]
#[doc = " example, if an unhandled exception error is ignored, that"]
#[doc = " effectively \"catches\" the unhandled exception.  Fatal errors must"]
#[doc = " always be propagated."]
#[doc = ""]
#[doc = " When an error is propagated, any current scopes created by"]
#[doc = " Dart_EnterScope will be exited."]
#[doc = ""]
#[doc = " Using Dart_SetReturnValue to propagate an exception is somewhat"]
#[doc = " more convenient than using Dart_PropagateError, and should be"]
#[doc = " preferred for reasons discussed below."]
#[doc = ""]
#[doc = " Dart_PropagateError and Dart_ThrowException do not return.  Instead"]
#[doc = " they transfer control non-locally using a setjmp-like mechanism."]
#[doc = " This can be inconvenient if you have resources that you need to"]
#[doc = " clean up before propagating the error."]
#[doc = ""]
#[doc = " When relying on Dart_PropagateError, we often return error handles"]
#[doc = " rather than propagating them from helper functions.  Consider the"]
#[doc = " following contrived example:"]
#[doc = ""]
#[doc = " 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {"]
#[doc = " 2      intptr_t* length = 0;"]
#[doc = " 3      result = Dart_StringLength(arg, &length);"]
#[doc = " 4      if (Dart_IsError(result)) {"]
#[doc = " 5        return result"]
#[doc = " 6      }"]
#[doc = " 7      return Dart_NewBoolean(length > 100);"]
#[doc = " 8    }"]
#[doc = " 9"]
#[doc = " 10   void NativeFunction_isLongString(Dart_NativeArguments args) {"]
#[doc = " 11     Dart_EnterScope();"]
#[doc = " 12     AllocateMyResource();"]
#[doc = " 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);"]
#[doc = " 14     Dart_Handle result = isLongStringHelper(arg);"]
#[doc = " 15     if (Dart_IsError(result)) {"]
#[doc = " 16       FreeMyResource();"]
#[doc = " 17       Dart_PropagateError(result);"]
#[doc = " 18       abort();  // will not reach here"]
#[doc = " 19     }"]
#[doc = " 20     Dart_SetReturnValue(result);"]
#[doc = " 21     FreeMyResource();"]
#[doc = " 22     Dart_ExitScope();"]
#[doc = " 23   }"]
#[doc = ""]
#[doc = " In this example, we have a native function which calls a helper"]
#[doc = " function to do its work.  On line 5, the helper function could call"]
#[doc = " Dart_PropagateError, but that would not give the native function a"]
#[doc = " chance to call FreeMyResource(), causing a leak.  Instead, the"]
#[doc = " helper function returns the error handle to the caller, giving the"]
#[doc = " caller a chance to clean up before propagating the error handle."]
#[doc = ""]
#[doc = " When an error is propagated by calling Dart_SetReturnValue, the"]
#[doc = " native function will be allowed to complete normally and then the"]
#[doc = " exception will be propagated only once the native call"]
#[doc = " returns. This can be convenient, as it allows the C code to clean"]
#[doc = " up normally."]
#[doc = ""]
#[doc = " The example can be written more simply using Dart_SetReturnValue to"]
#[doc = " propagate the error."]
#[doc = ""]
#[doc = " 1    Dart_Handle isLongStringHelper(Dart_Handle arg) {"]
#[doc = " 2      intptr_t* length = 0;"]
#[doc = " 3      result = Dart_StringLength(arg, &length);"]
#[doc = " 4      if (Dart_IsError(result)) {"]
#[doc = " 5        return result"]
#[doc = " 6      }"]
#[doc = " 7      return Dart_NewBoolean(length > 100);"]
#[doc = " 8    }"]
#[doc = " 9"]
#[doc = " 10   void NativeFunction_isLongString(Dart_NativeArguments args) {"]
#[doc = " 11     Dart_EnterScope();"]
#[doc = " 12     AllocateMyResource();"]
#[doc = " 13     Dart_Handle arg = Dart_GetNativeArgument(args, 0);"]
#[doc = " 14     Dart_SetReturnValue(isLongStringHelper(arg));"]
#[doc = " 15     FreeMyResource();"]
#[doc = " 16     Dart_ExitScope();"]
#[doc = " 17   }"]
#[doc = ""]
#[doc = " In this example, the call to Dart_SetReturnValue on line 14 will"]
#[doc = " either return the normal return value or the error (potentially"]
#[doc = " generated on line 3).  The call to FreeMyResource on line 15 will"]
#[doc = " execute in either case."]
#[doc = ""]
#[doc = " --- Local and persistent handles ---"]
#[doc = ""]
#[doc = " Local handles are allocated within the current scope (see"]
#[doc = " Dart_EnterScope) and go away when the current scope exits. Unless"]
#[doc = " otherwise indicated, callers should assume that all functions in"]
#[doc = " the Dart embedding api return local handles."]
#[doc = ""]
#[doc = " Persistent handles are allocated within the current isolate. They"]
#[doc = " can be used to store objects across scopes. Persistent handles have"]
#[doc = " the lifetime of the current isolate unless they are explicitly"]
#[doc = " deallocated (see Dart_DeletePersistentHandle)."]
#[doc = " The type Dart_Handle represents a handle (both local and persistent)."]
#[doc = " The type Dart_PersistentHandle is a Dart_Handle and it is used to"]
#[doc = " document that a persistent handle is expected as a parameter to a call"]
#[doc = " or the return value from a call is a persistent handle."]
pub type Dart_Handle = *mut _Dart_Handle;
pub type Dart_PersistentHandle = Dart_Handle;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_WeakPersistentHandle {
    _unused: [u8; 0],
}

pub type Dart_WeakPersistentHandle = *mut _Dart_WeakPersistentHandle;
pub type Dart_WeakPersistentHandleFinalizer = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_callback_data: *mut ::std::os::raw::c_void,
        handle: Dart_WeakPersistentHandle,
        peer: *mut ::std::os::raw::c_void,
    ),
>;

extern "C" {
    #[doc = " Is this an error handle?"]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_IsError(handle: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Is this an api error handle?"]
    #[doc = ""]
    #[doc = " Api error handles are produced when an api function is misused."]
    #[doc = " This happens when a Dart embedding api function is called with"]
    #[doc = " invalid arguments or in an invalid context."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_IsApiError(handle: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Is this an unhandled exception error handle?"]
    #[doc = ""]
    #[doc = " Unhandled exception error handles are produced when, during the"]
    #[doc = " execution of Dart code, an exception is thrown but not caught."]
    #[doc = " This can occur in any function which triggers the execution of Dart"]
    #[doc = " code."]
    #[doc = ""]
    #[doc = " See Dart_ErrorGetException and Dart_ErrorGetStackTrace."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_IsUnhandledExceptionError(handle: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Is this a compilation error handle?"]
    #[doc = ""]
    #[doc = " Compilation error handles are produced when, during the execution"]
    #[doc = " of Dart code, a compile-time error occurs.  This can occur in any"]
    #[doc = " function which triggers the execution of Dart code."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_IsCompilationError(handle: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Is this a fatal error handle?"]
    #[doc = ""]
    #[doc = " Fatal error handles are produced when the system wants to shut down"]
    #[doc = " the current isolate."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_IsFatalError(handle: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Gets the error message from an error handle."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\return A C string containing an error message if the handle is"]
    #[doc = "   error. An empty C string (\"\") if the handle is valid. This C"]
    #[doc = "   String is scope allocated and is only valid until the next call"]
    #[doc = "   to Dart_ExitScope."]
    pub fn Dart_GetError(handle: Dart_Handle) -> *const ::std::os::raw::c_char;
}

extern "C" {
    #[doc = " Is this an error handle for an unhandled exception?"]
    pub fn Dart_ErrorHasException(handle: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Gets the exception Object from an unhandled exception error handle."]
    pub fn Dart_ErrorGetException(handle: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the stack trace Object from an unhandled exception error handle."]
    pub fn Dart_ErrorGetStackTrace(handle: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Produces an api error handle with the provided error message."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\param error the error message."]
    pub fn Dart_NewApiError(error: *const ::std::os::raw::c_char) -> Dart_Handle;
}

extern "C" {
    pub fn Dart_NewCompilationError(error: *const ::std::os::raw::c_char) -> Dart_Handle;
}

extern "C" {
    #[doc = " Produces a new unhandled exception error handle."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\param exception An instance of a Dart object to be thrown or"]
    #[doc = "        an ApiError or CompilationError handle."]
    #[doc = "        When an ApiError or CompilationError handle is passed in"]
    #[doc = "        a string object of the error message is created and it becomes"]
    #[doc = "        the Dart object to be thrown."]
    pub fn Dart_NewUnhandledExceptionError(exception: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Propagates an error."]
    #[doc = ""]
    #[doc = " If the provided handle is an unhandled exception error, this"]
    #[doc = " function will cause the unhandled exception to be rethrown.  This"]
    #[doc = " will proceed in the standard way, walking up Dart frames until an"]
    #[doc = " appropriate 'catch' block is found, executing 'finally' blocks,"]
    #[doc = " etc."]
    #[doc = ""]
    #[doc = " If the error is not an unhandled exception error, we will unwind"]
    #[doc = " the stack to the next C frame.  Intervening Dart frames will be"]
    #[doc = " discarded; specifically, 'finally' blocks will not execute.  This"]
    #[doc = " is the standard way that compilation errors (and the like) are"]
    #[doc = " handled by the Dart runtime."]
    #[doc = ""]
    #[doc = " In either case, when an error is propagated any current scopes"]
    #[doc = " created by Dart_EnterScope will be exited."]
    #[doc = ""]
    #[doc = " See the additional discussion under \"Propagating Errors\" at the"]
    #[doc = " beginning of this file."]
    #[doc = ""]
    #[doc = " \\param An error handle (See Dart_IsError)"]
    #[doc = ""]
    #[doc = " \\return On success, this function does not return.  On failure, the"]
    #[doc = " process is terminated."]
    pub fn Dart_PropagateError(handle: Dart_Handle);
}

extern "C" {
    #[doc = " Converts an object to a string."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\return The converted string if no error occurs during"]
    #[doc = "   the conversion. If an error does occur, an error handle is"]
    #[doc = "   returned."]
    pub fn Dart_ToString(object: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Checks to see if two handles refer to identically equal objects."]
    #[doc = ""]
    #[doc = " If both handles refer to instances, this is equivalent to using the top-level"]
    #[doc = " function identical() from dart:core. Otherwise, returns whether the two"]
    #[doc = " argument handles refer to the same object."]
    #[doc = ""]
    #[doc = " \\param obj1 An object to be compared."]
    #[doc = " \\param obj2 An object to be compared."]
    #[doc = ""]
    #[doc = " \\return True if the objects are identically equal.  False otherwise."]
    pub fn Dart_IdentityEquals(obj1: Dart_Handle, obj2: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Allocates a handle in the current scope from a persistent handle."]
    pub fn Dart_HandleFromPersistent(object: Dart_PersistentHandle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Allocates a handle in the current scope from a weak persistent handle."]
    pub fn Dart_HandleFromWeakPersistent(object: Dart_WeakPersistentHandle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Allocates a persistent handle for an object."]
    #[doc = ""]
    #[doc = " This handle has the lifetime of the current isolate unless it is"]
    #[doc = " explicitly deallocated by calling Dart_DeletePersistentHandle."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_NewPersistentHandle(object: Dart_Handle) -> Dart_PersistentHandle;
}

extern "C" {
    #[doc = " Assign value of local handle to a persistent handle."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\param obj1 A persistent handle whose value needs to be set."]
    #[doc = " \\param obj2 An object whose value needs to be set to the persistent handle."]
    #[doc = ""]
    #[doc = " \\return Success if the persistent handle was set"]
    #[doc = "   Otherwise, returns an error."]
    pub fn Dart_SetPersistentHandle(obj1: Dart_PersistentHandle, obj2: Dart_Handle);
}

extern "C" {
    #[doc = " Deallocates a persistent handle."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_DeletePersistentHandle(object: Dart_PersistentHandle);
}

extern "C" {
    #[doc = " Allocates a weak persistent handle for an object."]
    #[doc = ""]
    #[doc = " This handle has the lifetime of the current isolate unless the object"]
    #[doc = " pointed to by the handle is garbage collected, in this case the VM"]
    #[doc = " automatically deletes the handle after invoking the callback associated"]
    #[doc = " with the handle. The handle can also be explicitly deallocated by"]
    #[doc = " calling Dart_DeleteWeakPersistentHandle."]
    #[doc = ""]
    #[doc = " If the object becomes unreachable the callback is invoked with the weak"]
    #[doc = " persistent handle and the peer as arguments. The callback is invoked on the"]
    #[doc = " thread that has entered the isolate at the time of garbage collection. This"]
    #[doc = " gives the embedder the ability to cleanup data associated with the object and"]
    #[doc = " clear out any cached references to the handle. All references to this handle"]
    #[doc = " after the callback will be invalid. It is illegal to call into the VM from"]
    #[doc = " the callback. If the handle is deleted before the object becomes unreachable,"]
    #[doc = " the callback is never invoked."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\param object An object."]
    #[doc = " \\param peer A pointer to a native object or NULL.  This value is"]
    #[doc = "   provided to callback when it is invoked."]
    #[doc = " \\param external_allocation_size The number of externally allocated"]
    #[doc = "   bytes for peer. Used to inform the garbage collector."]
    #[doc = " \\param callback A function pointer that will be invoked sometime"]
    #[doc = "   after the object is garbage collected, unless the handle has been deleted."]
    #[doc = "   A valid callback needs to be specified it cannot be NULL."]
    #[doc = ""]
    #[doc = " \\return The weak persistent handle or NULL. NULL is returned in case of bad"]
    #[doc = "   parameters."]
    pub fn Dart_NewWeakPersistentHandle(
        object: Dart_Handle,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_WeakPersistentHandleFinalizer,
    ) -> Dart_WeakPersistentHandle;
}

extern "C" {
    pub fn Dart_DeleteWeakPersistentHandle(
        isolate: Dart_Isolate,
        object: Dart_WeakPersistentHandle,
    );
}

extern "C" {
    #[doc = " Gets the version string for the Dart VM."]
    #[doc = ""]
    #[doc = " The version of the Dart VM can be accessed without initializing the VM."]
    #[doc = ""]
    #[doc = " \\return The version string for the embedded Dart VM."]
    pub fn Dart_VersionString() -> *const ::std::os::raw::c_char;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_QualifiedFunctionName {
    pub library_uri: *const ::std::os::raw::c_char,
    pub class_name: *const ::std::os::raw::c_char,
    pub function_name: *const ::std::os::raw::c_char,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_IsolateFlags {
    pub version: i32,
    pub enable_asserts: bool,
    pub use_field_guards: bool,
    pub use_osr: bool,
    pub obfuscate: bool,
    pub entry_points: *mut Dart_QualifiedFunctionName,
    pub load_vmservice_library: bool,
    pub unsafe_trust_strong_mode_types: bool,
    pub copy_parent_code: bool,
}

extern "C" {
    #[doc = " Initialize Dart_IsolateFlags with correct version and default values."]
    pub fn Dart_IsolateFlagsInitialize(flags: *mut Dart_IsolateFlags);
}

#[doc = " An isolate creation and initialization callback function."]
#[doc = ""]
#[doc = " This callback, provided by the embedder, is called when the VM"]
#[doc = " needs to create an isolate. The callback should create an isolate"]
#[doc = " by calling Dart_CreateIsolateGroup and load any scripts required for"]
#[doc = " execution."]
#[doc = ""]
#[doc = " This callback may be called on a different thread than the one"]
#[doc = " running the parent isolate."]
#[doc = ""]
#[doc = " When the function returns NULL, it is the responsibility of this"]
#[doc = " function to ensure that Dart_ShutdownIsolate has been called if"]
#[doc = " required (for example, if the isolate was created successfully by"]
#[doc = " Dart_CreateIsolateGroup() but the root library fails to load"]
#[doc = " successfully, then the function should call Dart_ShutdownIsolate"]
#[doc = " before returning)."]
#[doc = ""]
#[doc = " When the function returns NULL, the function should set *error to"]
#[doc = " a malloc-allocated buffer containing a useful error message.  The"]
#[doc = " caller of this function (the VM) will make sure that the buffer is"]
#[doc = " freed."]
#[doc = ""]
#[doc = " \\param script_uri The uri of the main source file or snapshot to load."]
#[doc = "   Either the URI of the parent isolate set in Dart_CreateIsolateGroup for"]
#[doc = "   Isolate.spawn, or the argument to Isolate.spawnUri canonicalized by the"]
#[doc = "   library tag handler of the parent isolate."]
#[doc = "   The callback is responsible for loading the program by a call to"]
#[doc = "   Dart_LoadScriptFromKernel."]
#[doc = " \\param main The name of the main entry point this isolate will"]
#[doc = "   eventually run.  This is provided for advisory purposes only to"]
#[doc = "   improve debugging messages.  The main function is not invoked by"]
#[doc = "   this function."]
#[doc = " \\param package_root The package root path for this isolate to resolve"]
#[doc = "   package imports against. Only one of package_root and package_map"]
#[doc = "   parameters is non-NULL. If neither parameter is passed the package"]
#[doc = "   resolution of the parent isolate should be used."]
#[doc = " \\param package_map The package map for this isolate to resolve package"]
#[doc = "   imports against. The array contains alternating keys and values,"]
#[doc = "   terminated by a NULL key. Only one of package_root and package_map"]
#[doc = "   parameters is non-NULL. If neither parameter is passed the package"]
#[doc = "   resolution of the parent isolate should be used."]
#[doc = " \\param flags Default flags for this isolate being spawned. Either inherited"]
#[doc = "   from the spawning isolate or passed as parameters when spawning the"]
#[doc = "   isolate from Dart code."]
#[doc = " \\param callback_data The callback data which was passed to the"]
#[doc = "   parent isolate when it was created by calling Dart_CreateIsolateGroup()."]
#[doc = " \\param error A structure into which the embedder can place a"]
#[doc = "   C string containing an error message in the case of failures."]
#[doc = ""]
#[doc = " \\return The embedder returns NULL if the creation and"]
#[doc = "   initialization was not successful and the isolate if successful."]
pub type Dart_IsolateGroupCreateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        script_uri: *const ::std::os::raw::c_char,
        main: *const ::std::os::raw::c_char,
        package_root: *const ::std::os::raw::c_char,
        package_config: *const ::std::os::raw::c_char,
        flags: *mut Dart_IsolateFlags,
        callback_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate,
>;
#[doc = " An isolate initialization callback function."]
#[doc = ""]
#[doc = " This callback, provided by the embedder, is called when the VM has created an"]
#[doc = " isolate within an existing isolate group (i.e. from the same source as an"]
#[doc = " existing isolate)."]
#[doc = ""]
#[doc = " The callback should setup native resolvers and might want to set a custom"]
#[doc = " message handler via [Dart_SetMessageNotifyCallback] and mark the isolate as"]
#[doc = " runnable."]
#[doc = ""]
#[doc = " This callback may be called on a different thread than the one"]
#[doc = " running the parent isolate."]
#[doc = ""]
#[doc = " When the function returns `false`, it is the responsibility of this"]
#[doc = " function to ensure that `Dart_ShutdownIsolate` has been called."]
#[doc = ""]
#[doc = " When the function returns `false`, the function should set *error to"]
#[doc = " a malloc-allocated buffer containing a useful error message.  The"]
#[doc = " caller of this function (the VM) will make sure that the buffer is"]
#[doc = " freed."]
#[doc = ""]
#[doc = " \\param child_isolate_data The callback data to associate with the new"]
#[doc = "        child isolate."]
#[doc = " \\param error A structure into which the embedder can place a"]
#[doc = "   C string containing an error message in the case the initialization fails."]
#[doc = ""]
#[doc = " \\return The embedder returns true if the initialization was successful and"]
#[doc = "         false otherwise (in which case the VM will terminate the isolate)."]
pub type Dart_InitializeIsolateCallback = ::std::option::Option<
    unsafe extern "C" fn(
        child_isolate_data: *mut *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool,
>;
#[doc = " An isolate unhandled exception callback function."]
#[doc = ""]
#[doc = " This callback has been DEPRECATED."]
pub type Dart_IsolateUnhandledExceptionCallback =
    ::std::option::Option<unsafe extern "C" fn(error: Dart_Handle)>;
#[doc = " An isolate shutdown callback function."]
#[doc = ""]
#[doc = " This callback, provided by the embedder, is called before the vm"]
#[doc = " shuts down an isolate.  The isolate being shutdown will be the current"]
#[doc = " isolate. It is safe to run Dart code."]
#[doc = ""]
#[doc = " This function should be used to dispose of native resources that"]
#[doc = " are allocated to an isolate in order to avoid leaks."]
#[doc = ""]
#[doc = " \\param isolate_group_data The same callback data which was passed to the"]
#[doc = "   isolate group when it was created."]
#[doc = " \\param isolate_data The same callback data which was passed to the isolate"]
#[doc = "   when it was created."]
pub type Dart_IsolateShutdownCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An isolate cleanup callback function."]
#[doc = ""]
#[doc = " This callback, provided by the embedder, is called after the vm"]
#[doc = " shuts down an isolate. There will be no current isolate and it is *not*"]
#[doc = " safe to run Dart code."]
#[doc = ""]
#[doc = " This function should be used to dispose of native resources that"]
#[doc = " are allocated to an isolate in order to avoid leaks."]
#[doc = ""]
#[doc = " \\param isolate_group_data The same callback data which was passed to the"]
#[doc = "   isolate group when it was created."]
#[doc = " \\param isolate_data The same callback data which was passed to the isolate"]
#[doc = "   when it was created."]
pub type Dart_IsolateCleanupCallback = ::std::option::Option<
    unsafe extern "C" fn(
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
    ),
>;
#[doc = " An isolate group cleanup callback function."]
#[doc = ""]
#[doc = " This callback, provided by the embedder, is called after the vm"]
#[doc = " shuts down an isolate group."]
#[doc = ""]
#[doc = " This function should be used to dispose of native resources that"]
#[doc = " are allocated to an isolate in order to avoid leaks."]
#[doc = ""]
#[doc = " \\param isolate_group_data The same callback data which was passed to the"]
#[doc = "   isolate group when it was created."]
#[doc = ""]
pub type Dart_IsolateGroupCleanupCallback =
    ::std::option::Option<unsafe extern "C" fn(isolate_group_data: *mut ::std::os::raw::c_void)>;
#[doc = " A thread death callback function."]
#[doc = " This callback, provided by the embedder, is called before a thread in the"]
#[doc = " vm thread pool exits."]
#[doc = " This function could be used to dispose of native resources that"]
#[doc = " are associated and attached to the thread, in order to avoid leaks."]
pub type Dart_ThreadExitCallback = ::std::option::Option<unsafe extern "C" fn()>;
#[doc = " Callbacks provided by the embedder for file operations. If the"]
#[doc = " embedder does not allow file operations these callbacks can be"]
#[doc = " NULL."]
#[doc = ""]
#[doc = " Dart_FileOpenCallback - opens a file for reading or writing."]
#[doc = " \\param name The name of the file to open."]
#[doc = " \\param write A boolean variable which indicates if the file is to"]
#[doc = "   opened for writing. If there is an existing file it needs to truncated."]
#[doc = ""]
#[doc = " Dart_FileReadCallback - Read contents of file."]
#[doc = " \\param data Buffer allocated in the callback into which the contents"]
#[doc = "   of the file are read into. It is the responsibility of the caller to"]
#[doc = "   free this buffer."]
#[doc = " \\param file_length A variable into which the length of the file is returned."]
#[doc = "   In the case of an error this value would be -1."]
#[doc = " \\param stream Handle to the opened file."]
#[doc = ""]
#[doc = " Dart_FileWriteCallback - Write data into file."]
#[doc = " \\param data Buffer which needs to be written into the file."]
#[doc = " \\param length Length of the buffer."]
#[doc = " \\param stream Handle to the opened file."]
#[doc = ""]
#[doc = " Dart_FileCloseCallback - Closes the opened file."]
#[doc = " \\param stream Handle to the opened file."]
#[doc = ""]
pub type Dart_FileOpenCallback = ::std::option::Option<
    unsafe extern "C" fn(
        name: *const ::std::os::raw::c_char,
        write: bool,
    ) -> *mut ::std::os::raw::c_void,
>;
pub type Dart_FileReadCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *mut *mut u8,
        file_length: *mut isize,
        stream: *mut ::std::os::raw::c_void,
    ),
>;
pub type Dart_FileWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        data: *const ::std::os::raw::c_void,
        length: isize,
        stream: *mut ::std::os::raw::c_void,
    ),
>;
pub type Dart_FileCloseCallback =
    ::std::option::Option<unsafe extern "C" fn(stream: *mut ::std::os::raw::c_void)>;
pub type Dart_EntropySource =
    ::std::option::Option<unsafe extern "C" fn(buffer: *mut u8, length: isize) -> bool>;
#[doc = " Callback provided by the embedder that is used by the vmservice isolate"]
#[doc = " to request the asset archive. The asset archive must be an uncompressed tar"]
#[doc = " archive that is stored in a Uint8List."]
#[doc = ""]
#[doc = " If the embedder has no vmservice isolate assets, the callback can be NULL."]
#[doc = ""]
#[doc = " \\return The embedder must return a handle to a Uint8List containing an"]
#[doc = "   uncompressed tar archive or null."]
pub type Dart_GetVMServiceAssetsArchive =
    ::std::option::Option<unsafe extern "C" fn() -> Dart_Handle>;
#[doc = " Callback provided by the embedder that is used by the VM to notify on code"]
#[doc = " object creation, *before* it is invoked the first time."]
#[doc = " This is useful for embedders wanting to e.g. keep track of PCs beyond"]
#[doc = " the lifetime of the garbage collected code objects."]
#[doc = " Note that an address range may be used by more than one code object over the"]
#[doc = " lifecycle of a process. Clients of this function should record timestamps for"]
#[doc = " these compilation events and when collecting PCs to disambiguate reused"]
#[doc = " address ranges."]
pub type Dart_OnNewCodeCallback = ::std::option::Option<
    unsafe extern "C" fn(
        observer: *mut Dart_CodeObserver,
        name: *const ::std::os::raw::c_char,
        base: usize,
        size: usize,
    ),
>;

#[doc = " Forward declaration"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_CodeObserver {
    pub data: *mut ::std::os::raw::c_void,
    pub on_new_code: Dart_OnNewCodeCallback,
}

#[doc = " Describes how to initialize the VM. Used with Dart_Initialize."]
#[doc = ""]
#[doc = " \\param version Identifies the version of the struct used by the client."]
#[doc = "   should be initialized to DART_INITIALIZE_PARAMS_CURRENT_VERSION."]
#[doc = " \\param vm_isolate_snapshot A buffer containing a snapshot of the VM isolate"]
#[doc = "   or NULL if no snapshot is provided. If provided, the buffer must remain"]
#[doc = "   valid until Dart_Cleanup returns."]
#[doc = " \\param instructions_snapshot A buffer containing a snapshot of precompiled"]
#[doc = "   instructions, or NULL if no snapshot is provided. If provided, the buffer"]
#[doc = "   must remain valid until Dart_Cleanup returns."]
#[doc = " \\param initialize_isolate A function to be called during isolate"]
#[doc = "   initialization inside an existing isolate group."]
#[doc = "   See Dart_InitializeIsolateCallback."]
#[doc = " \\param create_group A function to be called during isolate group creation."]
#[doc = "   See Dart_IsolateGroupCreateCallback."]
#[doc = " \\param shutdown A function to be called right before an isolate is shutdown."]
#[doc = "   See Dart_IsolateShutdownCallback."]
#[doc = " \\param cleanup A function to be called after an isolate was shutdown."]
#[doc = "   See Dart_IsolateCleanupCallback."]
#[doc = " \\param cleanup_group A function to be called after an isolate group is shutdown."]
#[doc = "   See Dart_IsolateGroupCleanupCallback."]
#[doc = " \\param get_service_assets A function to be called by the service isolate when"]
#[doc = "    it requires the vmservice assets archive."]
#[doc = "    See Dart_GetVMServiceAssetsArchive."]
#[doc = " \\param code_observer An external code observer callback function."]
#[doc = "    The observer can be invoked as early as during the Dart_Initialize() call."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_InitializeParams {
    pub version: i32,
    pub vm_snapshot_data: *const u8,
    pub vm_snapshot_instructions: *const u8,
    pub create_group: Dart_IsolateGroupCreateCallback,
    pub initialize_isolate: Dart_InitializeIsolateCallback,
    pub shutdown_isolate: Dart_IsolateShutdownCallback,
    pub cleanup_isolate: Dart_IsolateCleanupCallback,
    pub cleanup_group: Dart_IsolateGroupCleanupCallback,
    pub thread_exit: Dart_ThreadExitCallback,
    pub file_open: Dart_FileOpenCallback,
    pub file_read: Dart_FileReadCallback,
    pub file_write: Dart_FileWriteCallback,
    pub file_close: Dart_FileCloseCallback,
    pub entropy_source: Dart_EntropySource,
    pub get_service_assets: Dart_GetVMServiceAssetsArchive,
    pub start_kernel_isolate: bool,
    pub code_observer: *mut Dart_CodeObserver,
}

extern "C" {
    #[doc = " Initializes the VM."]
    #[doc = ""]
    #[doc = " \\param flags A struct containing initialization information. The version"]
    #[doc = "   field of the struct must be DART_INITIALIZE_PARAMS_CURRENT_VERSION."]
    #[doc = ""]
    #[doc = " \\return NULL if initialization is successful. Returns an error message"]
    #[doc = "   otherwise. The caller is responsible for freeing the error message."]
    pub fn Dart_Initialize(params: *mut Dart_InitializeParams) -> *mut ::std::os::raw::c_char;
}

extern "C" {
    #[doc = " Cleanup state in the VM before process termination."]
    #[doc = ""]
    #[doc = " \\return NULL if cleanup is successful. Returns an error message otherwise."]
    #[doc = "   The caller is responsible for freeing the error message."]
    pub fn Dart_Cleanup() -> *mut ::std::os::raw::c_char;
}

extern "C" {
    #[doc = " Sets command line flags. Should be called before Dart_Initialize."]
    #[doc = ""]
    #[doc = " \\param argc The length of the arguments array."]
    #[doc = " \\param argv An array of arguments."]
    #[doc = ""]
    #[doc = " \\return NULL if successful. Returns an error message otherwise."]
    #[doc = "  The caller is responsible for freeing the error message."]
    pub fn Dart_SetVMFlags(
        argc: ::std::os::raw::c_int,
        argv: *mut *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}

extern "C" {
    #[doc = " Returns true if the named VM flag is set."]
    pub fn Dart_IsVMFlagSet(flag_name: *const ::std::os::raw::c_char) -> bool;
}

extern "C" {
    #[doc = " Creates a new isolate. The new isolate becomes the current isolate."]
    #[doc = ""]
    #[doc = " A snapshot can be used to restore the VM quickly to a saved state"]
    #[doc = " and is useful for fast startup. If snapshot data is provided, the"]
    #[doc = " isolate will be started using that snapshot data. Requires a core snapshot or"]
    #[doc = " an app snapshot created by Dart_CreateSnapshot or"]
    #[doc = " Dart_CreatePrecompiledSnapshot* from a VM with the same version."]
    #[doc = ""]
    #[doc = " Requires there to be no current isolate."]
    #[doc = ""]
    #[doc = " \\param script_uri The main source file or snapshot this isolate will load."]
    #[doc = "   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a child"]
    #[doc = "   isolate is created by Isolate.spawn. The embedder should use a URI that"]
    #[doc = "   allows it to load the same program into such a child isolate."]
    #[doc = " \\param name A short name for the isolate to improve debugging messages."]
    #[doc = "   Typically of the format 'foo.dart:main()'."]
    #[doc = " \\param isolate_snapshot_data"]
    #[doc = " \\param isolate_snapshot_instructions Buffers containing a snapshot of the"]
    #[doc = "   isolate or NULL if no snapshot is provided. If provided, the buffers must"]
    #[doc = "   remain valid until the isolate shuts down."]
    #[doc = " \\param flags Pointer to VM specific flags or NULL for default flags."]
    #[doc = " \\param callback_data Embedder data.  This data will be passed to"]
    #[doc = "   the Dart_IsolateGroupCreateCallback when new isolates are spawned from"]
    #[doc = "   this parent isolate."]
    #[doc = " \\param error Returns NULL if creation is successful, an error message"]
    #[doc = "   otherwise. The caller is responsible for calling free() on the error"]
    #[doc = "   message."]
    #[doc = ""]
    #[doc = " \\return The new isolate on success, or NULL if isolate creation failed."]
    pub fn Dart_CreateIsolateGroup(
        script_uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        isolate_snapshot_data: *const u8,
        isolate_snapshot_instructions: *const u8,
        flags: *mut Dart_IsolateFlags,
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}

extern "C" {
    #[doc = " Creates a new isolate from a Dart Kernel file. The new isolate"]
    #[doc = " becomes the current isolate."]
    #[doc = ""]
    #[doc = " Requires there to be no current isolate."]
    #[doc = ""]
    #[doc = " \\param script_uri The main source file or snapshot this isolate will load."]
    #[doc = "   The VM will provide this URI to the Dart_IsolateGroupCreateCallback when a child"]
    #[doc = "   isolate is created by Isolate.spawn. The embedder should use a URI that"]
    #[doc = "   allows it to load the same program into such a child isolate."]
    #[doc = " \\param name A short name for the isolate to improve debugging messages."]
    #[doc = "   Typically of the format 'foo.dart:main()'."]
    #[doc = " \\param kernel_buffer"]
    #[doc = " \\param kernel_buffer_size A buffer which contains a kernel/DIL program. Must"]
    #[doc = "   remain valid until isolate shutdown."]
    #[doc = " \\param flags Pointer to VM specific flags or NULL for default flags."]
    #[doc = " \\param callback_data Embedder data.  This data will be passed to"]
    #[doc = "   the Dart_IsolateGroupCreateCallback when new isolates are spawned from"]
    #[doc = "   this parent isolate."]
    #[doc = " \\param error Returns NULL if creation is successful, an error message"]
    #[doc = "   otherwise. The caller is responsible for calling free() on the error"]
    #[doc = "   message."]
    #[doc = ""]
    #[doc = " \\return The new isolate on success, or NULL if isolate creation failed."]
    pub fn Dart_CreateIsolateGroupFromKernel(
        script_uri: *const ::std::os::raw::c_char,
        name: *const ::std::os::raw::c_char,
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
        flags: *mut Dart_IsolateFlags,
        isolate_group_data: *mut ::std::os::raw::c_void,
        isolate_data: *mut ::std::os::raw::c_void,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> Dart_Isolate;
}

extern "C" {
    #[doc = " Shuts down the current isolate. After this call, the current isolate is NULL."]
    #[doc = " Any current scopes created by Dart_EnterScope will be exited. Invokes the"]
    #[doc = " shutdown callback and any callbacks of remaining weak persistent handles."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_ShutdownIsolate();
}

extern "C" {
    #[doc = " Returns the current isolate. Will return NULL if there is no"]
    #[doc = " current isolate."]
    pub fn Dart_CurrentIsolate() -> Dart_Isolate;
}

extern "C" {
    #[doc = " Returns the callback data associated with the current isolate. This"]
    #[doc = " data was set when the isolate got created or initialized."]
    pub fn Dart_CurrentIsolateData() -> *mut ::std::os::raw::c_void;
}

extern "C" {
    #[doc = " Returns the callback data associated with the given isolate. This"]
    #[doc = " data was set when the isolate got created or initialized."]
    pub fn Dart_IsolateData(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    #[doc = " Returns the callback data associated with the current isolate group. This"]
    #[doc = " data was passed to the isolate group when it was created."]
    pub fn Dart_CurrentIsolateGroupData() -> *mut ::std::os::raw::c_void;
}

extern "C" {
    #[doc = " Returns the callback data associated with the specified isolate group. This"]
    #[doc = " data was passed to the isolate when it was created."]
    #[doc = " The embedder is responsible for ensuring the consistency of this data"]
    #[doc = " with respect to the lifecycle of an isolate group."]
    pub fn Dart_IsolateGroupData(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_void;
}

extern "C" {
    #[doc = " Returns the debugging name for the current isolate."]
    #[doc = ""]
    #[doc = " This name is unique to each isolate and should only be used to make"]
    #[doc = " debugging messages more comprehensible."]
    pub fn Dart_DebugName() -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the ID for an isolate which is used to query the service protocol."]
    #[doc = ""]
    #[doc = " It is the responsibility of the caller to free the returned ID."]
    pub fn Dart_IsolateServiceId(isolate: Dart_Isolate) -> *const ::std::os::raw::c_char;
}

extern "C" {
    #[doc = " Enters an isolate. After calling this function,"]
    #[doc = " the current isolate will be set to the provided isolate."]
    #[doc = ""]
    #[doc = " Requires there to be no current isolate. Multiple threads may not be in"]
    #[doc = " the same isolate at once."]
    pub fn Dart_EnterIsolate(isolate: Dart_Isolate);
}

extern "C" {
    #[doc = " Kills the given isolate."]
    #[doc = ""]
    #[doc = " This function has the same effect as dart:isolate's"]
    #[doc = " Isolate.kill(priority:immediate)."]
    #[doc = " It can interrupt ordinary Dart code but not native code. If the isolate is"]
    #[doc = " in the middle of a long running native function, the isolate will not be"]
    #[doc = " killed until control returns to Dart."]
    #[doc = ""]
    #[doc = " Does not require a current isolate. It is safe to kill the current isolate if"]
    #[doc = " there is one."]
    pub fn Dart_KillIsolate(isolate: Dart_Isolate);
}

extern "C" {
    #[doc = " Notifies the VM that the embedder expects to be idle until |deadline|. The VM"]
    #[doc = " may use this time to perform garbage collection or other tasks to avoid"]
    #[doc = " delays during execution of Dart code in the future."]
    #[doc = ""]
    #[doc = " |deadline| is measured in microseconds against the system's monotonic time."]
    #[doc = " This clock can be accessed via Dart_TimelineGetMicros()."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_NotifyIdle(deadline: i64);
}

extern "C" {
    #[doc = " Notifies the VM that the system is running low on memory."]
    #[doc = ""]
    #[doc = " Does not require a current isolate. Only valid after calling Dart_Initialize."]
    pub fn Dart_NotifyLowMemory();
}

extern "C" {
    #[doc = " Starts the CPU sampling profiler."]
    pub fn Dart_StartProfiling();
}

extern "C" {
    #[doc = " Stops the CPU sampling profiler."]
    #[doc = ""]
    #[doc = " Note that some profile samples might still be taken after this fucntion"]
    #[doc = " returns due to the asynchronous nature of the implementation on some"]
    #[doc = " platforms."]
    pub fn Dart_StopProfiling();
}

extern "C" {
    #[doc = " Notifies the VM that the current thread should not be profiled until a"]
    #[doc = " matching call to Dart_ThreadEnableProfiling is made."]
    #[doc = ""]
    #[doc = " NOTE: By default, if a thread has entered an isolate it will be profiled."]
    #[doc = " This function should be used when an embedder knows a thread is about"]
    #[doc = " to make a blocking call and wants to avoid unnecessary interrupts by"]
    #[doc = " the profiler."]
    pub fn Dart_ThreadDisableProfiling();
}

extern "C" {
    #[doc = " Notifies the VM that the current thread should be profiled."]
    #[doc = ""]
    #[doc = " NOTE: It is only legal to call this function *after* calling"]
    #[doc = "   Dart_ThreadDisableProfiling."]
    #[doc = ""]
    #[doc = " NOTE: By default, if a thread has entered an isolate it will be profiled."]
    pub fn Dart_ThreadEnableProfiling();
}

extern "C" {
    #[doc = " Register symbol information for the Dart VM's profiler and crash dumps."]
    #[doc = ""]
    #[doc = " This consumes the output of //topaz/runtime/dart/profiler_symbols, which"]
    #[doc = " should be treated as opaque."]
    pub fn Dart_AddSymbols(
        dso_name: *const ::std::os::raw::c_char,
        buffer: *mut ::std::os::raw::c_void,
        buffer_size: isize,
    );
}

extern "C" {
    #[doc = " Exits an isolate. After this call, Dart_CurrentIsolate will"]
    #[doc = " return NULL."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_ExitIsolate();
}

extern "C" {
    #[doc = " Creates a full snapshot of the current isolate heap."]
    #[doc = ""]
    #[doc = " A full snapshot is a compact representation of the dart vm isolate heap"]
    #[doc = " and dart isolate heap states. These snapshots are used to initialize"]
    #[doc = " the vm isolate on startup and fast initialization of an isolate."]
    #[doc = " A Snapshot of the heap is created before any dart code has executed."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate. Not available in the precompiled"]
    #[doc = " runtime (check Dart_IsPrecompiledRuntime)."]
    #[doc = ""]
    #[doc = " \\param buffer Returns a pointer to a buffer containing the"]
    #[doc = "   snapshot. This buffer is scope allocated and is only valid"]
    #[doc = "   until the next call to Dart_ExitScope."]
    #[doc = " \\param size Returns the size of the buffer."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateSnapshot(
        vm_snapshot_data_buffer: *mut *mut u8,
        vm_snapshot_data_size: *mut isize,
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns whether the buffer contains a kernel file."]
    #[doc = ""]
    #[doc = " \\param buffer Pointer to a buffer that might contain a kernel binary."]
    #[doc = " \\param buffer_size Size of the buffer."]
    #[doc = ""]
    #[doc = " \\return Whether the buffer contains a kernel binary (full or partial)."]
    pub fn Dart_IsKernel(buffer: *const u8, buffer_size: isize) -> bool;
}

extern "C" {
    #[doc = " Make isolate runnable."]
    #[doc = ""]
    #[doc = " When isolates are spawned, this function is used to indicate that"]
    #[doc = " the creation and initialization (including script loading) of the"]
    #[doc = " isolate is complete and the isolate can start."]
    #[doc = " This function expects there to be no current isolate."]
    #[doc = ""]
    #[doc = " \\param isolate The isolate to be made runnable."]
    #[doc = ""]
    #[doc = " \\return NULL if successful. Returns an error message otherwise. The caller"]
    #[doc = " is responsible for freeing the error message."]
    pub fn Dart_IsolateMakeRunnable(isolate: Dart_Isolate) -> *mut ::std::os::raw::c_char;
}

#[doc = " A port is used to send or receive inter-isolate messages"]
pub type Dart_Port = i64;
#[doc = " A message notification callback."]
#[doc = ""]
#[doc = " This callback allows the embedder to provide an alternate wakeup"]
#[doc = " mechanism for the delivery of inter-isolate messages.  It is the"]
#[doc = " responsibility of the embedder to call Dart_HandleMessage to"]
#[doc = " process the message."]
pub type Dart_MessageNotifyCallback =
    ::std::option::Option<unsafe extern "C" fn(dest_isolate: Dart_Isolate)>;

extern "C" {
    #[doc = " Allows embedders to provide an alternative wakeup mechanism for the"]
    #[doc = " delivery of inter-isolate messages. This setting only applies to"]
    #[doc = " the current isolate."]
    #[doc = ""]
    #[doc = " Most embedders will only call this function once, before isolate"]
    #[doc = " execution begins. If this function is called after isolate"]
    #[doc = " execution begins, the embedder is responsible for threading issues."]
    pub fn Dart_SetMessageNotifyCallback(message_notify_callback: Dart_MessageNotifyCallback);
}

extern "C" {
    #[doc = " Query the current message notify callback for the isolate."]
    #[doc = ""]
    #[doc = " \\return The current message notify callback for the isolate."]
    pub fn Dart_GetMessageNotifyCallback() -> Dart_MessageNotifyCallback;
}

extern "C" {
    #[doc = " If the VM flag `--pause-isolates-on-start` was passed this will be true."]
    #[doc = ""]
    #[doc = " \\return A boolean value indicating if pause on start was requested."]
    pub fn Dart_ShouldPauseOnStart() -> bool;
}

extern "C" {
    #[doc = " Override the VM flag `--pause-isolates-on-start` for the current isolate."]
    #[doc = ""]
    #[doc = " \\param should_pause Should the isolate be paused on start?"]
    #[doc = ""]
    #[doc = " NOTE: This must be called before Dart_IsolateMakeRunnable."]
    pub fn Dart_SetShouldPauseOnStart(should_pause: bool);
}

extern "C" {
    #[doc = " Is the current isolate paused on start?"]
    #[doc = ""]
    #[doc = " \\return A boolean value indicating if the isolate is paused on start."]
    pub fn Dart_IsPausedOnStart() -> bool;
}

extern "C" {
    #[doc = " Called when the embedder has paused the current isolate on start and when"]
    #[doc = " the embedder has resumed the isolate."]
    #[doc = ""]
    #[doc = " \\param paused Is the isolate paused on start?"]
    pub fn Dart_SetPausedOnStart(paused: bool);
}

extern "C" {
    #[doc = " If the VM flag `--pause-isolates-on-exit` was passed this will be true."]
    #[doc = ""]
    #[doc = " \\return A boolean value indicating if pause on exit was requested."]
    pub fn Dart_ShouldPauseOnExit() -> bool;
}

extern "C" {
    #[doc = " Override the VM flag `--pause-isolates-on-exit` for the current isolate."]
    #[doc = ""]
    #[doc = " \\param should_pause Should the isolate be paused on exit?"]
    #[doc = ""]
    pub fn Dart_SetShouldPauseOnExit(should_pause: bool);
}

extern "C" {
    #[doc = " Is the current isolate paused on exit?"]
    #[doc = ""]
    #[doc = " \\return A boolean value indicating if the isolate is paused on exit."]
    pub fn Dart_IsPausedOnExit() -> bool;
}

extern "C" {
    #[doc = " Called when the embedder has paused the current isolate on exit and when"]
    #[doc = " the embedder has resumed the isolate."]
    #[doc = ""]
    #[doc = " \\param paused Is the isolate paused on exit?"]
    pub fn Dart_SetPausedOnExit(paused: bool);
}

extern "C" {
    #[doc = " Called when the embedder has caught a top level unhandled exception error"]
    #[doc = " in the current isolate."]
    #[doc = ""]
    #[doc = " NOTE: It is illegal to call this twice on the same isolate without first"]
    #[doc = " clearing the sticky error to null."]
    #[doc = ""]
    #[doc = " \\param error The unhandled exception error."]
    pub fn Dart_SetStickyError(error: Dart_Handle);
}

extern "C" {
    #[doc = " Does the current isolate have a sticky error?"]
    pub fn Dart_HasStickyError() -> bool;
}

extern "C" {
    #[doc = " Gets the sticky error for the current isolate."]
    #[doc = ""]
    #[doc = " \\return A handle to the sticky error object or null."]
    pub fn Dart_GetStickyError() -> Dart_Handle;
}

extern "C" {
    #[doc = " Handles the next pending message for the current isolate."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_HandleMessage() -> Dart_Handle;
}

extern "C" {
    #[doc = " Drains the microtask queue, then blocks the calling thread until the current"]
    #[doc = " isolate recieves a message, then handles all messages."]
    #[doc = ""]
    #[doc = " \\param timeout_millis When non-zero, the call returns after the indicated"]
    #[doc = "number of milliseconds even if no message was received."]
    #[doc = " \\return A valid handle if no error occurs, otherwise an error handle."]
    pub fn Dart_WaitForEvent(timeout_millis: i64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Handles any pending messages for the vm service for the current"]
    #[doc = " isolate."]
    #[doc = ""]
    #[doc = " This function may be used by an embedder at a breakpoint to avoid"]
    #[doc = " pausing the vm service."]
    #[doc = ""]
    #[doc = " This function can indirectly cause the message notify callback to"]
    #[doc = " be called."]
    #[doc = ""]
    #[doc = " \\return true if the vm service requests the program resume"]
    #[doc = " execution, false otherwise"]
    pub fn Dart_HandleServiceMessages() -> bool;
}

extern "C" {
    #[doc = " Does the current isolate have pending service messages?"]
    #[doc = ""]
    #[doc = " \\return true if the isolate has pending service messages, false otherwise."]
    pub fn Dart_HasServiceMessages() -> bool;
}

extern "C" {
    #[doc = " Processes any incoming messages for the current isolate."]
    #[doc = ""]
    #[doc = " This function may only be used when the embedder has not provided"]
    #[doc = " an alternate message delivery mechanism with"]
    #[doc = " Dart_SetMessageCallbacks. It is provided for convenience."]
    #[doc = ""]
    #[doc = " This function waits for incoming messages for the current"]
    #[doc = " isolate. As new messages arrive, they are handled using"]
    #[doc = " Dart_HandleMessage. The routine exits when all ports to the"]
    #[doc = " current isolate are closed."]
    #[doc = ""]
    #[doc = " \\return A valid handle if the run loop exited successfully.  If an"]
    #[doc = "   exception or other error occurs while processing messages, an"]
    #[doc = "   error handle is returned."]
    pub fn Dart_RunLoop() -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the main port id for the current isolate."]
    pub fn Dart_GetMainPortId() -> Dart_Port;
}

extern "C" {
    #[doc = " Does the current isolate have live ReceivePorts?"]
    #[doc = ""]
    #[doc = " A ReceivePort is live when it has not been closed."]
    pub fn Dart_HasLivePorts() -> bool;
}

extern "C" {
    #[doc = " Posts a message for some isolate. The message is a serialized"]
    #[doc = " object."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\param port The destination port."]
    #[doc = " \\param object An object from the current isolate."]
    #[doc = ""]
    #[doc = " \\return True if the message was posted."]
    pub fn Dart_Post(port_id: Dart_Port, object: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Returns a new SendPort with the provided port id."]
    #[doc = ""]
    #[doc = " \\param port_id The destination port."]
    #[doc = ""]
    #[doc = " \\return A new SendPort if no errors occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewSendPort(port_id: Dart_Port) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the SendPort id for the provided SendPort."]
    #[doc = " \\param port A SendPort object whose id is desired."]
    #[doc = " \\param port_id Returns the id of the SendPort."]
    #[doc = " \\return Success if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_SendPortGetId(port: Dart_Handle, port_id: *mut Dart_Port) -> Dart_Handle;
}

extern "C" {
    #[doc = " Enters a new scope."]
    #[doc = ""]
    #[doc = " All new local handles will be created in this scope. Additionally,"]
    #[doc = " some functions may return \"scope allocated\" memory which is only"]
    #[doc = " valid within this scope."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_EnterScope();
}

extern "C" {
    #[doc = " Exits a scope."]
    #[doc = ""]
    #[doc = " The previous scope (if any) becomes the current scope."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    pub fn Dart_ExitScope();
}

extern "C" {
    #[doc = " The Dart VM uses \"zone allocation\" for temporary structures. Zones"]
    #[doc = " support very fast allocation of small chunks of memory. The chunks"]
    #[doc = " cannot be deallocated individually, but instead zones support"]
    #[doc = " deallocating all chunks in one fast operation."]
    #[doc = ""]
    #[doc = " This function makes it possible for the embedder to allocate"]
    #[doc = " temporary data in the VMs zone allocator."]
    #[doc = ""]
    #[doc = " Zone allocation is possible:"]
    #[doc = "   1. when inside a scope where local handles can be allocated"]
    #[doc = "   2. when processing a message from a native port in a native port"]
    #[doc = "      handler"]
    #[doc = ""]
    #[doc = " All the memory allocated this way will be reclaimed either on the"]
    #[doc = " next call to Dart_ExitScope or when the native port handler exits."]
    #[doc = ""]
    #[doc = " \\param size Size of the memory to allocate."]
    #[doc = ""]
    #[doc = " \\return A pointer to the allocated memory. NULL if allocation"]
    #[doc = "   failed. Failure might due to is no current VM zone."]
    pub fn Dart_ScopeAllocate(size: isize) -> *mut u8;
}

extern "C" {
    #[doc = " Returns the null object."]
    #[doc = ""]
    #[doc = " \\return A handle to the null object."]
    pub fn Dart_Null() -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the empty string object."]
    #[doc = ""]
    #[doc = " \\return A handle to the empty string object."]
    pub fn Dart_EmptyString() -> Dart_Handle;
}

extern "C" {
    #[doc = " Is this object null?"]
    pub fn Dart_IsNull(object: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Checks if the two objects are equal."]
    #[doc = ""]
    #[doc = " The result of the comparison is returned through the 'equal'"]
    #[doc = " parameter. The return value itself is used to indicate success or"]
    #[doc = " failure, not equality."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param obj1 An object to be compared."]
    #[doc = " \\param obj2 An object to be compared."]
    #[doc = " \\param equal Returns the result of the equality comparison."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the comparison."]
    pub fn Dart_ObjectEquals(obj1: Dart_Handle, obj2: Dart_Handle, equal: *mut bool)
        -> Dart_Handle;
}

extern "C" {
    #[doc = " Is this object an instance of some type?"]
    #[doc = ""]
    #[doc = " The result of the test is returned through the 'instanceof' parameter."]
    #[doc = " The return value itself is used to indicate success or failure."]
    #[doc = ""]
    #[doc = " \\param object An object."]
    #[doc = " \\param type A type."]
    #[doc = " \\param instanceof Return true if 'object' is an instance of type 'type'."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ObjectIsType(
        object: Dart_Handle,
        type_: Dart_Handle,
        instanceof: *mut bool,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Query object type."]
    #[doc = ""]
    #[doc = " \\param object Some Object."]
    #[doc = ""]
    #[doc = " \\return true if Object is of the specified type."]
    pub fn Dart_IsInstance(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsNumber(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsInteger(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsDouble(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsBoolean(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsString(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsStringLatin1(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsExternalString(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsList(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsMap(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsLibrary(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsType(handle: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsFunction(handle: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsVariable(handle: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsTypeVariable(handle: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsClosure(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsTypedData(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsByteBuffer(object: Dart_Handle) -> bool;
}

extern "C" {
    pub fn Dart_IsFuture(object: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Gets the type of a Dart language object."]
    #[doc = ""]
    #[doc = " \\param instance Some Dart object."]
    #[doc = ""]
    #[doc = " \\return If no error occurs, the type is returned. Otherwise an"]
    #[doc = "   error handle is returned."]
    pub fn Dart_InstanceGetType(instance: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the name for the provided class type."]
    #[doc = ""]
    #[doc = " \\return A valid string handle if no error occurs during the"]
    #[doc = "   operation."]
    pub fn Dart_ClassName(cls_type: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the name for the provided function or method."]
    #[doc = ""]
    #[doc = " \\return A valid string handle if no error occurs during the"]
    #[doc = "   operation."]
    pub fn Dart_FunctionName(function: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a handle to the owner of a function."]
    #[doc = ""]
    #[doc = " The owner of an instance method or a static method is its defining"]
    #[doc = " class. The owner of a top-level function is its defining"]
    #[doc = " library. The owner of the function of a non-implicit closure is the"]
    #[doc = " function of the method or closure that defines the non-implicit"]
    #[doc = " closure."]
    #[doc = ""]
    #[doc = " \\return A valid handle to the owner of the function, or an error"]
    #[doc = "   handle if the argument is not a valid handle to a function."]
    pub fn Dart_FunctionOwner(function: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Determines whether a function handle referes to a static function"]
    #[doc = " of method."]
    #[doc = ""]
    #[doc = " For the purposes of the embedding API, a top-level function is"]
    #[doc = " implicitly declared static."]
    #[doc = ""]
    #[doc = " \\param function A handle to a function or method declaration."]
    #[doc = " \\param is_static Returns whether the function or method is declared static."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_FunctionIsStatic(function: Dart_Handle, is_static: *mut bool) -> Dart_Handle;
}

extern "C" {
    #[doc = " Is this object a closure resulting from a tear-off (closurized method)?"]
    #[doc = ""]
    #[doc = " Returns true for closures produced when an ordinary method is accessed"]
    #[doc = " through a getter call. Returns false otherwise, in particular for closures"]
    #[doc = " produced from local function declarations."]
    #[doc = ""]
    #[doc = " \\param object Some Object."]
    #[doc = ""]
    #[doc = " \\return true if Object is a tear-off."]
    pub fn Dart_IsTearOff(object: Dart_Handle) -> bool;
}

extern "C" {
    #[doc = " Retrieves the function of a closure."]
    #[doc = ""]
    #[doc = " \\return A handle to the function of the closure, or an error handle if the"]
    #[doc = "   argument is not a closure."]
    pub fn Dart_ClosureFunction(closure: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a handle to the library which contains class."]
    #[doc = ""]
    #[doc = " \\return A valid handle to the library with owns class, null if the class"]
    #[doc = "   has no library or an error handle if the argument is not a valid handle"]
    #[doc = "   to a class type."]
    pub fn Dart_ClassLibrary(cls_type: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Does this Integer fit into a 64-bit signed integer?"]
    #[doc = ""]
    #[doc = " \\param integer An integer."]
    #[doc = " \\param fits Returns true if the integer fits into a 64-bit signed integer."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerFitsIntoInt64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}

extern "C" {
    #[doc = " Does this Integer fit into a 64-bit unsigned integer?"]
    #[doc = ""]
    #[doc = " \\param integer An integer."]
    #[doc = " \\param fits Returns true if the integer fits into a 64-bit unsigned integer."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerFitsIntoUint64(integer: Dart_Handle, fits: *mut bool) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns an Integer with the provided value."]
    #[doc = ""]
    #[doc = " \\param value The value of the integer."]
    #[doc = ""]
    #[doc = " \\return The Integer object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewInteger(value: i64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns an Integer with the provided value."]
    #[doc = ""]
    #[doc = " \\param value The unsigned value of the integer."]
    #[doc = ""]
    #[doc = " \\return The Integer object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewIntegerFromUint64(value: u64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns an Integer with the provided value."]
    #[doc = ""]
    #[doc = " \\param value The value of the integer represented as a C string"]
    #[doc = "   containing a hexadecimal number."]
    #[doc = ""]
    #[doc = " \\return The Integer object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewIntegerFromHexCString(value: *const ::std::os::raw::c_char) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of an Integer."]
    #[doc = ""]
    #[doc = " The integer must fit into a 64-bit signed integer, otherwise an error occurs."]
    #[doc = ""]
    #[doc = " \\param integer An Integer."]
    #[doc = " \\param value Returns the value of the Integer."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToInt64(integer: Dart_Handle, value: *mut i64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of an Integer."]
    #[doc = ""]
    #[doc = " The integer must fit into a 64-bit unsigned integer, otherwise an"]
    #[doc = " error occurs."]
    #[doc = ""]
    #[doc = " \\param integer An Integer."]
    #[doc = " \\param value Returns the value of the Integer."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToUint64(integer: Dart_Handle, value: *mut u64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of an integer as a hexadecimal C string."]
    #[doc = ""]
    #[doc = " \\param integer An Integer."]
    #[doc = " \\param value Returns the value of the Integer as a hexadecimal C"]
    #[doc = "   string. This C string is scope allocated and is only valid until"]
    #[doc = "   the next call to Dart_ExitScope."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_IntegerToHexCString(
        integer: Dart_Handle,
        value: *mut *const ::std::os::raw::c_char,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a Double with the provided value."]
    #[doc = ""]
    #[doc = " \\param value A double."]
    #[doc = ""]
    #[doc = " \\return The Double object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewDouble(value: f64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of a Double"]
    #[doc = ""]
    #[doc = " \\param double_obj A Double"]
    #[doc = " \\param value Returns the value of the Double."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_DoubleValue(double_obj: Dart_Handle, value: *mut f64) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a closure of static function 'function_name' in the class 'class_name'"]
    #[doc = " in the exported namespace of specified 'library'."]
    #[doc = ""]
    #[doc = " \\param library Library object"]
    #[doc = " \\param cls_type Type object representing a Class"]
    #[doc = " \\param function_name Name of the static function in the class"]
    #[doc = ""]
    #[doc = " \\return A valid Dart instance if no error occurs during the operation."]
    pub fn Dart_GetStaticMethodClosure(
        library: Dart_Handle,
        cls_type: Dart_Handle,
        function_name: Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the True object."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\return A handle to the True object."]
    pub fn Dart_True() -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the False object."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\return A handle to the False object."]
    pub fn Dart_False() -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a Boolean with the provided value."]
    #[doc = ""]
    #[doc = " \\param value true or false."]
    #[doc = ""]
    #[doc = " \\return The Boolean object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewBoolean(value: bool) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of a Boolean"]
    #[doc = ""]
    #[doc = " \\param boolean_obj A Boolean"]
    #[doc = " \\param value Returns the value of the Boolean."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_BooleanValue(boolean_obj: Dart_Handle, value: *mut bool) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the length of a String."]
    #[doc = ""]
    #[doc = " \\param str A String."]
    #[doc = " \\param length Returns the length of the String."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringLength(str: Dart_Handle, length: *mut isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a String built from the provided C string"]
    #[doc = " (There is an implicit assumption that the C string passed in contains"]
    #[doc = "  UTF-8 encoded characters and '\\0' is considered as a termination"]
    #[doc = "  character)."]
    #[doc = ""]
    #[doc = " \\param value A C String"]
    #[doc = ""]
    #[doc = " \\return The String object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewStringFromCString(str: *const ::std::os::raw::c_char) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a String built from an array of UTF-8 encoded characters."]
    #[doc = ""]
    #[doc = " \\param utf8_array An array of UTF-8 encoded characters."]
    #[doc = " \\param length The length of the codepoints array."]
    #[doc = ""]
    #[doc = " \\return The String object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewStringFromUTF8(utf8_array: *const u8, length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a String built from an array of UTF-16 encoded characters."]
    #[doc = ""]
    #[doc = " \\param utf16_array An array of UTF-16 encoded characters."]
    #[doc = " \\param length The length of the codepoints array."]
    #[doc = ""]
    #[doc = " \\return The String object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewStringFromUTF16(utf16_array: *const u16, length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a String built from an array of UTF-32 encoded characters."]
    #[doc = ""]
    #[doc = " \\param utf32_array An array of UTF-32 encoded characters."]
    #[doc = " \\param length The length of the codepoints array."]
    #[doc = ""]
    #[doc = " \\return The String object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewStringFromUTF32(utf32_array: *const i32, length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a String which references an external array of"]
    #[doc = " Latin-1 (ISO-8859-1) encoded characters."]
    #[doc = ""]
    #[doc = " \\param latin1_array Array of Latin-1 encoded characters. This must not move."]
    #[doc = " \\param length The length of the characters array."]
    #[doc = " \\param peer An external pointer to associate with this string."]
    #[doc = " \\param external_allocation_size The number of externally allocated"]
    #[doc = "   bytes for peer. Used to inform the garbage collector."]
    #[doc = " \\param callback A callback to be called when this string is finalized."]
    #[doc = ""]
    #[doc = " \\return The String object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewExternalLatin1String(
        latin1_array: *const u8,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_WeakPersistentHandleFinalizer,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a String which references an external array of UTF-16 encoded"]
    #[doc = " characters."]
    #[doc = ""]
    #[doc = " \\param utf16_array An array of UTF-16 encoded characters. This must not move."]
    #[doc = " \\param length The length of the characters array."]
    #[doc = " \\param peer An external pointer to associate with this string."]
    #[doc = " \\param external_allocation_size The number of externally allocated"]
    #[doc = "   bytes for peer. Used to inform the garbage collector."]
    #[doc = " \\param callback A callback to be called when this string is finalized."]
    #[doc = ""]
    #[doc = " \\return The String object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewExternalUTF16String(
        utf16_array: *const u16,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_WeakPersistentHandleFinalizer,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the C string representation of a String."]
    #[doc = " (It is a sequence of UTF-8 encoded values with a '\\0' termination.)"]
    #[doc = ""]
    #[doc = " \\param str A string."]
    #[doc = " \\param cstr Returns the String represented as a C string."]
    #[doc = "   This C string is scope allocated and is only valid until"]
    #[doc = "   the next call to Dart_ExitScope."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToCString(
        str: Dart_Handle,
        cstr: *mut *const ::std::os::raw::c_char,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets a UTF-8 encoded representation of a String."]
    #[doc = ""]
    #[doc = " \\param str A string."]
    #[doc = " \\param utf8_array Returns the String represented as UTF-8 code"]
    #[doc = "   units.  This UTF-8 array is scope allocated and is only valid"]
    #[doc = "   until the next call to Dart_ExitScope."]
    #[doc = " \\param length Used to return the length of the array which was"]
    #[doc = "   actually used."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToUTF8(
        str: Dart_Handle,
        utf8_array: *mut *mut u8,
        length: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the data corresponding to the string object. This function returns"]
    #[doc = " the data only for Latin-1 (ISO-8859-1) string objects. For all other"]
    #[doc = " string objects it returns an error."]
    #[doc = ""]
    #[doc = " \\param str A string."]
    #[doc = " \\param latin1_array An array allocated by the caller, used to return"]
    #[doc = "   the string data."]
    #[doc = " \\param length Used to pass in the length of the provided array."]
    #[doc = "   Used to return the length of the array which was actually used."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToLatin1(
        str: Dart_Handle,
        latin1_array: *mut u8,
        length: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the UTF-16 encoded representation of a string."]
    #[doc = ""]
    #[doc = " \\param str A string."]
    #[doc = " \\param utf16_array An array allocated by the caller, used to return"]
    #[doc = "   the array of UTF-16 encoded characters."]
    #[doc = " \\param length Used to pass in the length of the provided array."]
    #[doc = "   Used to return the length of the array which was actually used."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringToUTF16(
        str: Dart_Handle,
        utf16_array: *mut u16,
        length: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the storage size in bytes of a String."]
    #[doc = ""]
    #[doc = " \\param str A String."]
    #[doc = " \\param length Returns the storage size in bytes of the String."]
    #[doc = "  This is the size in bytes needed to store the String."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_StringStorageSize(str: Dart_Handle, size: *mut isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Retrieves some properties associated with a String."]
    #[doc = " Properties retrieved are:"]
    #[doc = " - character size of the string (one or two byte)"]
    #[doc = " - length of the string"]
    #[doc = " - peer pointer of string if it is an external string."]
    #[doc = " \\param str A String."]
    #[doc = " \\param char_size Returns the character size of the String."]
    #[doc = " \\param str_len Returns the length of the String."]
    #[doc = " \\param peer Returns the peer pointer associated with the String or 0 if"]
    #[doc = "   there is no peer pointer for it."]
    #[doc = " \\return Success if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_StringGetProperties(
        str: Dart_Handle,
        char_size: *mut isize,
        str_len: *mut isize,
        peer: *mut *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a List<dynamic> of the desired length."]
    #[doc = ""]
    #[doc = " \\param length The length of the list."]
    #[doc = ""]
    #[doc = " \\return The List object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewList(length: isize) -> Dart_Handle;
}

#[repr(i32)]
#[derive(Clone, Copy, Debug, PartialEq, Eq)]
pub enum Dart_CoreType_Id {
    Dynamic = 0,
    Int = 1,
    String = 2,
}

extern "C" {
    #[doc = " Returns a List of the desired length with the desired element type."]
    #[doc = ""]
    #[doc = " \\param element_type_id The type of elements of the list."]
    #[doc = ""]
    #[doc = " \\param length The length of the list."]
    #[doc = ""]
    #[doc = " \\return The List object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewListOf(element_type_id: Dart_CoreType_Id, length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a List of the desired length with the desired element type."]
    #[doc = ""]
    #[doc = " \\param element_type Handle to a type object. E.g., from Dart_GetType."]
    #[doc = ""]
    #[doc = " \\param length The length of the list."]
    #[doc = ""]
    #[doc = " \\return The List object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewListOfType(element_type: Dart_Handle, length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the length of a List."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param list A List."]
    #[doc = " \\param length Returns the length of the List."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ListLength(list: Dart_Handle, length: *mut isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the Object at some index of a List."]
    #[doc = ""]
    #[doc = " If the index is out of bounds, an error occurs."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param list A List."]
    #[doc = " \\param index A valid index into the List."]
    #[doc = ""]
    #[doc = " \\return The Object in the List at the specified index if no error"]
    #[doc = "   occurs. Otherwise returns an error handle."]
    pub fn Dart_ListGetAt(list: Dart_Handle, index: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets a range of Objects from a List."]
    #[doc = ""]
    #[doc = " If any of the requested index values are out of bounds, an error occurs."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param list A List."]
    #[doc = " \\param offset The offset of the first item to get."]
    #[doc = " \\param length The number of items to get."]
    #[doc = " \\param result A pointer to fill with the objects."]
    #[doc = ""]
    #[doc = " \\return Success if no error occurs during the operation."]
    pub fn Dart_ListGetRange(
        list: Dart_Handle,
        offset: isize,
        length: isize,
        result: *mut Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the Object at some index of a List."]
    #[doc = ""]
    #[doc = " If the index is out of bounds, an error occurs."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param array A List."]
    #[doc = " \\param index A valid index into the List."]
    #[doc = " \\param value The Object to put in the List."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_ListSetAt(list: Dart_Handle, index: isize, value: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " May generate an unhandled exception error."]
    pub fn Dart_ListGetAsBytes(
        list: Dart_Handle,
        offset: isize,
        native_array: *mut u8,
        length: isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " May generate an unhandled exception error."]
    pub fn Dart_ListSetAsBytes(
        list: Dart_Handle,
        offset: isize,
        native_array: *const u8,
        length: isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the Object at some key of a Map."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param map A Map."]
    #[doc = " \\param key An Object."]
    #[doc = ""]
    #[doc = " \\return The value in the map at the specified key, null if the map does not"]
    #[doc = "   contain the key, or an error handle."]
    pub fn Dart_MapGetAt(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns whether the Map contains a given key."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param map A Map."]
    #[doc = ""]
    #[doc = " \\return A handle on a boolean indicating whether map contains the key."]
    #[doc = "   Otherwise returns an error handle."]
    pub fn Dart_MapContainsKey(map: Dart_Handle, key: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the list of keys of a Map."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param map A Map."]
    #[doc = ""]
    #[doc = " \\return The list of key Objects if no error occurs. Otherwise returns an"]
    #[doc = "   error handle."]
    pub fn Dart_MapKeys(map: Dart_Handle) -> Dart_Handle;
}

#[repr(i32)]
#[derive(Copy, Clone, PartialEq, Eq, Debug)]
pub enum Dart_TypedData_Type {
    ByteData = 0,
    Int8 = 1,
    Uint8 = 2,
    Uint8Clamped = 3,
    Int16 = 4,
    Uint16 = 5,
    Int32 = 6,
    Uint32 = 7,
    Int64 = 8,
    Uint64 = 9,
    Float32 = 10,
    Float64 = 11,
    Float32x4 = 12,
    Invalid = 13,
}

extern "C" {
    #[doc = " Return type if this object is a TypedData object."]
    #[doc = ""]
    #[doc = " \\return kInvalid if the object is not a TypedData object or the appropriate"]
    #[doc = "   Dart_TypedData_Type."]
    pub fn Dart_GetTypeOfTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}

extern "C" {
    #[doc = " Return type if this object is an external TypedData object."]
    #[doc = ""]
    #[doc = " \\return kInvalid if the object is not an external TypedData object or"]
    #[doc = "   the appropriate Dart_TypedData_Type."]
    pub fn Dart_GetTypeOfExternalTypedData(object: Dart_Handle) -> Dart_TypedData_Type;
}

extern "C" {
    #[doc = " Returns a TypedData object of the desired length and type."]
    #[doc = ""]
    #[doc = " \\param type The type of the TypedData object."]
    #[doc = " \\param length The length of the TypedData object (length in type units)."]
    #[doc = ""]
    #[doc = " \\return The TypedData object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewTypedData(type_: Dart_TypedData_Type, length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a TypedData object which references an external data array."]
    #[doc = ""]
    #[doc = " \\param type The type of the data array."]
    #[doc = " \\param data A data array. This array must not move."]
    #[doc = " \\param length The length of the data array (length in type units)."]
    #[doc = ""]
    #[doc = " \\return The TypedData object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewExternalTypedData(
        type_: Dart_TypedData_Type,
        data: *mut ::std::os::raw::c_void,
        length: isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a TypedData object which references an external data array."]
    #[doc = ""]
    #[doc = " \\param type The type of the data array."]
    #[doc = " \\param data A data array. This array must not move."]
    #[doc = " \\param length The length of the data array (length in type units)."]
    #[doc = " \\param peer A pointer to a native object or NULL.  This value is"]
    #[doc = "   provided to callback when it is invoked."]
    #[doc = " \\param external_allocation_size The number of externally allocated"]
    #[doc = "   bytes for peer. Used to inform the garbage collector."]
    #[doc = " \\param callback A function pointer that will be invoked sometime"]
    #[doc = "   after the object is garbage collected, unless the handle has been deleted."]
    #[doc = "   A valid callback needs to be specified it cannot be NULL."]
    #[doc = ""]
    #[doc = " \\return The TypedData object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewExternalTypedDataWithFinalizer(
        type_: Dart_TypedData_Type,
        data: *mut ::std::os::raw::c_void,
        length: isize,
        peer: *mut ::std::os::raw::c_void,
        external_allocation_size: isize,
        callback: Dart_WeakPersistentHandleFinalizer,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a ByteBuffer object for the typed data."]
    #[doc = ""]
    #[doc = " \\param type_data The TypedData object."]
    #[doc = ""]
    #[doc = " \\return The ByteBuffer object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_NewByteBuffer(typed_data: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Acquires access to the internal data address of a TypedData object."]
    #[doc = ""]
    #[doc = " \\param object The typed data object whose internal data address is to"]
    #[doc = "    be accessed."]
    #[doc = " \\param type The type of the object is returned here."]
    #[doc = " \\param data The internal data address is returned here."]
    #[doc = " \\param len Size of the typed array is returned here."]
    #[doc = ""]
    #[doc = " Notes:"]
    #[doc = "   When the internal address of the object is acquired any calls to a"]
    #[doc = "   Dart API function that could potentially allocate an object or run"]
    #[doc = "   any Dart code will return an error."]
    #[doc = ""]
    #[doc = "   Any Dart API functions for accessing the data should not be called"]
    #[doc = "   before the corresponding release. In particular, the object should"]
    #[doc = "   not be acquired again before its release. This leads to undefined"]
    #[doc = "   behavior."]
    #[doc = ""]
    #[doc = " \\return Success if the internal data address is acquired successfully."]
    #[doc = "   Otherwise, returns an error handle."]
    pub fn Dart_TypedDataAcquireData(
        object: Dart_Handle,
        type_: *mut Dart_TypedData_Type,
        data: *mut *mut ::std::os::raw::c_void,
        len: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Releases access to the internal data address that was acquired earlier using"]
    #[doc = " Dart_TypedDataAcquireData."]
    #[doc = ""]
    #[doc = " \\param object The typed data object whose internal data address is to be"]
    #[doc = "   released."]
    #[doc = ""]
    #[doc = " \\return Success if the internal data address is released successfully."]
    #[doc = "   Otherwise, returns an error handle."]
    pub fn Dart_TypedDataReleaseData(object: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the TypedData object associated with the ByteBuffer object."]
    #[doc = ""]
    #[doc = " \\param byte_buffer The ByteBuffer object."]
    #[doc = ""]
    #[doc = " \\return The TypedData object if no error occurs. Otherwise returns"]
    #[doc = "   an error handle."]
    pub fn Dart_GetDataFromByteBuffer(byte_buffer: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Invokes a constructor, creating a new object."]
    #[doc = ""]
    #[doc = " This function allows hidden constructors (constructors with leading"]
    #[doc = " underscores) to be called."]
    #[doc = ""]
    #[doc = " \\param type Type of object to be constructed."]
    #[doc = " \\param constructor_name The name of the constructor to invoke.  Use"]
    #[doc = "   Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor."]
    #[doc = "   This name should not include the name of the class."]
    #[doc = " \\param number_of_arguments Size of the arguments array."]
    #[doc = " \\param arguments An array of arguments to the constructor."]
    #[doc = ""]
    #[doc = " \\return If the constructor is called and completes successfully,"]
    #[doc = "   then the new object. If an error occurs during execution, then an"]
    #[doc = "   error handle is returned."]
    pub fn Dart_New(
        type_: Dart_Handle,
        constructor_name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Allocate a new object without invoking a constructor."]
    #[doc = ""]
    #[doc = " \\param type The type of an object to be allocated."]
    #[doc = ""]
    #[doc = " \\return The new object. If an error occurs during execution, then an"]
    #[doc = "   error handle is returned."]
    pub fn Dart_Allocate(type_: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Allocate a new object without invoking a constructor, and sets specified"]
    #[doc = "  native fields."]
    #[doc = ""]
    #[doc = " \\param type The type of an object to be allocated."]
    #[doc = " \\param num_native_fields The number of native fields to set."]
    #[doc = " \\param native_fields An array containing the value of native fields."]
    #[doc = ""]
    #[doc = " \\return The new object. If an error occurs during execution, then an"]
    #[doc = "   error handle is returned."]
    pub fn Dart_AllocateWithNativeFields(
        type_: Dart_Handle,
        num_native_fields: isize,
        native_fields: *const isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Invokes a method or function."]
    #[doc = ""]
    #[doc = " The 'target' parameter may be an object, type, or library.  If"]
    #[doc = " 'target' is an object, then this function will invoke an instance"]
    #[doc = " method.  If 'target' is a type, then this function will invoke a"]
    #[doc = " static method.  If 'target' is a library, then this function will"]
    #[doc = " invoke a top-level function from that library."]
    #[doc = " NOTE: This API call cannot be used to invoke methods of a type object."]
    #[doc = ""]
    #[doc = " This function ignores visibility (leading underscores in names)."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param target An object, type, or library."]
    #[doc = " \\param name The name of the function or method to invoke."]
    #[doc = " \\param number_of_arguments Size of the arguments array."]
    #[doc = " \\param arguments An array of arguments to the function."]
    #[doc = ""]
    #[doc = " \\return If the function or method is called and completes"]
    #[doc = "   successfully, then the return value is returned. If an error"]
    #[doc = "   occurs during execution, then an error handle is returned."]
    pub fn Dart_Invoke(
        target: Dart_Handle,
        name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Invokes a Closure with the given arguments."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\return If no error occurs during execution, then the result of"]
    #[doc = "   invoking the closure is returned. If an error occurs during"]
    #[doc = "   execution, then an error handle is returned."]
    pub fn Dart_InvokeClosure(
        closure: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Invokes a Generative Constructor on an object that was previously"]
    #[doc = " allocated using Dart_Allocate/Dart_AllocateWithNativeFields."]
    #[doc = ""]
    #[doc = " The 'target' parameter must be an object."]
    #[doc = ""]
    #[doc = " This function ignores visibility (leading underscores in names)."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param target An object."]
    #[doc = " \\param name The name of the constructor to invoke."]
    #[doc = "   Use Dart_Null() or Dart_EmptyString() to invoke the unnamed constructor."]
    #[doc = " \\param number_of_arguments Size of the arguments array."]
    #[doc = " \\param arguments An array of arguments to the function."]
    #[doc = ""]
    #[doc = " \\return If the constructor is called and completes"]
    #[doc = "   successfully, then the object is returned. If an error"]
    #[doc = "   occurs during execution, then an error handle is returned."]
    pub fn Dart_InvokeConstructor(
        object: Dart_Handle,
        name: Dart_Handle,
        number_of_arguments: ::std::os::raw::c_int,
        arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of a field."]
    #[doc = ""]
    #[doc = " The 'container' parameter may be an object, type, or library.  If"]
    #[doc = " 'container' is an object, then this function will access an"]
    #[doc = " instance field.  If 'container' is a type, then this function will"]
    #[doc = " access a static field.  If 'container' is a library, then this"]
    #[doc = " function will access a top-level variable."]
    #[doc = " NOTE: This API call cannot be used to access fields of a type object."]
    #[doc = ""]
    #[doc = " This function ignores field visibility (leading underscores in names)."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param container An object, type, or library."]
    #[doc = " \\param name A field name."]
    #[doc = ""]
    #[doc = " \\return If no error occurs, then the value of the field is"]
    #[doc = "   returned. Otherwise an error handle is returned."]
    pub fn Dart_GetField(container: Dart_Handle, name: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the value of a field."]
    #[doc = ""]
    #[doc = " The 'container' parameter may actually be an object, type, or"]
    #[doc = " library.  If 'container' is an object, then this function will"]
    #[doc = " access an instance field.  If 'container' is a type, then this"]
    #[doc = " function will access a static field.  If 'container' is a library,"]
    #[doc = " then this function will access a top-level variable."]
    #[doc = " NOTE: This API call cannot be used to access fields of a type object."]
    #[doc = ""]
    #[doc = " This function ignores field visibility (leading underscores in names)."]
    #[doc = ""]
    #[doc = " May generate an unhandled exception error."]
    #[doc = ""]
    #[doc = " \\param container An object, type, or library."]
    #[doc = " \\param name A field name."]
    #[doc = " \\param value The new field value."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs."]
    pub fn Dart_SetField(
        container: Dart_Handle,
        name: Dart_Handle,
        value: Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Throws an exception."]
    #[doc = ""]
    #[doc = " This function causes a Dart language exception to be thrown. This"]
    #[doc = " will proceed in the standard way, walking up Dart frames until an"]
    #[doc = " appropriate 'catch' block is found, executing 'finally' blocks,"]
    #[doc = " etc."]
    #[doc = ""]
    #[doc = " If an error handle is passed into this function, the error is"]
    #[doc = " propagated immediately.  See Dart_PropagateError for a discussion"]
    #[doc = " of error propagation."]
    #[doc = ""]
    #[doc = " If successful, this function does not return. Note that this means"]
    #[doc = " that the destructors of any stack-allocated C++ objects will not be"]
    #[doc = " called. If there are no Dart frames on the stack, an error occurs."]
    #[doc = ""]
    #[doc = " \\return An error handle if the exception was not thrown."]
    #[doc = "   Otherwise the function does not return."]
    pub fn Dart_ThrowException(exception: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Rethrows an exception."]
    #[doc = ""]
    #[doc = " Rethrows an exception, unwinding all dart frames on the stack. If"]
    #[doc = " successful, this function does not return. Note that this means"]
    #[doc = " that the destructors of any stack-allocated C++ objects will not be"]
    #[doc = " called. If there are no Dart frames on the stack, an error occurs."]
    #[doc = ""]
    #[doc = " \\return An error handle if the exception was not thrown."]
    #[doc = "   Otherwise the function does not return."]
    pub fn Dart_ReThrowException(exception: Dart_Handle, stacktrace: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the number of native instance fields in an object."]
    pub fn Dart_GetNativeInstanceFieldCount(
        obj: Dart_Handle,
        count: *mut ::std::os::raw::c_int,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the value of a native field."]
    #[doc = ""]
    #[doc = " TODO(turnidge): Document."]
    pub fn Dart_GetNativeInstanceField(
        obj: Dart_Handle,
        index: ::std::os::raw::c_int,
        value: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the value of a native field."]
    #[doc = ""]
    #[doc = " TODO(turnidge): Document."]
    pub fn Dart_SetNativeInstanceField(
        obj: Dart_Handle,
        index: ::std::os::raw::c_int,
        value: isize,
    ) -> Dart_Handle;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArguments {
    _unused: [u8; 0],
}

#[doc = " The arguments to a native function."]
#[doc = ""]
#[doc = " This object is passed to a native function to represent its"]
#[doc = " arguments and return value. It allows access to the arguments to a"]
#[doc = " native function by index. It also allows the return value of a"]
#[doc = " native function to be set."]
pub type Dart_NativeArguments = *mut _Dart_NativeArguments;

extern "C" {
    #[doc = " Extracts current isolate group data from the native arguments structure."]
    pub fn Dart_GetNativeIsolateGroupData(
        args: Dart_NativeArguments,
    ) -> *mut ::std::os::raw::c_void;
}

#[repr(u8)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Dart_NativeArgument_Type {
    Bool = 0,
    Int32 = 1,
    Uint32 = 2,
    Int64 = 3,
    Uint64 = 4,
    Double = 5,
    String = 6,
    Instance = 7,
    NativeFields = 8,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _Dart_NativeArgument_Descriptor {
    pub type_: Dart_NativeArgument_Type,
    pub index: u8,
}

pub type Dart_NativeArgument_Descriptor = _Dart_NativeArgument_Descriptor;

#[repr(C)]
#[derive(Copy, Clone)]
pub union Dart_NativeArgument_Value {
    pub as_bool: bool,
    pub as_int32: i32,
    pub as_uint32: u32,
    pub as_int64: i64,
    pub as_uint64: u64,
    pub as_double: f64,
    pub as_string: Dart_NativeString,
    pub as_native_fields: Dart_NativeFields,
    pub as_instance: Dart_Handle,
    _bindgen_union_align: [u64; 2usize],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_NativeString {
    pub dart_str: Dart_Handle,
    pub peer: *mut ::std::os::raw::c_void,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_NativeFields {
    pub num_fields: isize,
    pub values: *mut isize,
}

pub const kNativeArgNumberPos: i32 = 0;
pub const kNativeArgNumberSize: i32 = 8;
pub const kNativeArgTypePos: i32 = 8;
pub const kNativeArgTypeSize: i32 = 8;

extern "C" {
    #[doc = " Gets the native arguments based on the types passed in and populates"]
    #[doc = " the passed arguments buffer with appropriate native values."]
    #[doc = ""]
    #[doc = " \\param args the Native arguments block passed into the native call."]
    #[doc = " \\param num_arguments length of argument descriptor array and argument"]
    #[doc = "   values array passed in."]
    #[doc = " \\param arg_descriptors an array that describes the arguments that"]
    #[doc = "   need to be retrieved. For each argument to be retrieved the descriptor"]
    #[doc = "   contains the argument number (0, 1 etc.) and the argument type"]
    #[doc = "   described using Dart_NativeArgument_Type, e.g:"]
    #[doc = "   DART_NATIVE_ARG_DESCRIPTOR(Dart_NativeArgument_kBool, 1) indicates"]
    #[doc = "   that the first argument is to be retrieved and it should be a boolean."]
    #[doc = " \\param arg_values array into which the native arguments need to be"]
    #[doc = "   extracted into, the array is allocated by the caller (it could be"]
    #[doc = "   stack allocated to avoid the malloc/free performance overhead)."]
    #[doc = ""]
    #[doc = " \\return Success if all the arguments could be extracted correctly,"]
    #[doc = "   returns an error handle if there were any errors while extracting the"]
    #[doc = "   arguments (mismatched number of arguments, incorrect types, etc.)."]
    pub fn Dart_GetNativeArguments(
        args: Dart_NativeArguments,
        num_arguments: ::std::os::raw::c_int,
        arg_descriptors: *const Dart_NativeArgument_Descriptor,
        arg_values: *mut Dart_NativeArgument_Value,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the native argument at some index."]
    pub fn Dart_GetNativeArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the number of native arguments."]
    pub fn Dart_GetNativeArgumentCount(args: Dart_NativeArguments) -> ::std::os::raw::c_int;
}

extern "C" {
    #[doc = " Gets all the native fields of the native argument at some index."]
    #[doc = " \\param args Native arguments structure."]
    #[doc = " \\param arg_index Index of the desired argument in the structure above."]
    #[doc = " \\param num_fields size of the intptr_t array 'field_values' passed in."]
    #[doc = " \\param field_values intptr_t array in which native field values are returned."]
    #[doc = " \\return Success if the native fields where copied in successfully. Otherwise"]
    #[doc = "   returns an error handle. On success the native field values are copied"]
    #[doc = "   into the 'field_values' array, if the argument at 'arg_index' is a"]
    #[doc = "   null object then 0 is copied as the native field values into the"]
    #[doc = "   'field_values' array."]
    pub fn Dart_GetNativeFieldsOfArgument(
        args: Dart_NativeArguments,
        arg_index: ::std::os::raw::c_int,
        num_fields: ::std::os::raw::c_int,
        field_values: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the native field of the receiver."]
    pub fn Dart_GetNativeReceiver(args: Dart_NativeArguments, value: *mut isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets a string native argument at some index."]
    #[doc = " \\param args Native arguments structure."]
    #[doc = " \\param arg_index Index of the desired argument in the structure above."]
    #[doc = " \\param peer Returns the peer pointer if the string argument has one."]
    #[doc = " \\return Success if the string argument has a peer, if it does not"]
    #[doc = "   have a peer then the String object is returned. Otherwise returns"]
    #[doc = "   an error handle (argument is not a String object)."]
    pub fn Dart_GetNativeStringArgument(
        args: Dart_NativeArguments,
        arg_index: ::std::os::raw::c_int,
        peer: *mut *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets an integer native argument at some index."]
    #[doc = " \\param args Native arguments structure."]
    #[doc = " \\param arg_index Index of the desired argument in the structure above."]
    #[doc = " \\param value Returns the integer value if the argument is an Integer."]
    #[doc = " \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeIntegerArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut i64,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets a boolean native argument at some index."]
    #[doc = " \\param args Native arguments structure."]
    #[doc = " \\param arg_index Index of the desired argument in the structure above."]
    #[doc = " \\param value Returns the boolean value if the argument is a Boolean."]
    #[doc = " \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeBooleanArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut bool,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets a double native argument at some index."]
    #[doc = " \\param args Native arguments structure."]
    #[doc = " \\param arg_index Index of the desired argument in the structure above."]
    #[doc = " \\param value Returns the double value if the argument is a double."]
    #[doc = " \\return Success if no error occurs. Otherwise returns an error handle."]
    pub fn Dart_GetNativeDoubleArgument(
        args: Dart_NativeArguments,
        index: ::std::os::raw::c_int,
        value: *mut f64,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the return value for a native function."]
    #[doc = ""]
    #[doc = " If retval is an Error handle, then error will be propagated once"]
    #[doc = " the native functions exits. See Dart_PropagateError for a"]
    #[doc = " discussion of how different types of errors are propagated."]
    pub fn Dart_SetReturnValue(args: Dart_NativeArguments, retval: Dart_Handle);
}

extern "C" {
    pub fn Dart_SetWeakHandleReturnValue(
        args: Dart_NativeArguments,
        rval: Dart_WeakPersistentHandle,
    );
}

extern "C" {
    pub fn Dart_SetBooleanReturnValue(args: Dart_NativeArguments, retval: bool);
}

extern "C" {
    pub fn Dart_SetIntegerReturnValue(args: Dart_NativeArguments, retval: i64);
}

extern "C" {
    pub fn Dart_SetDoubleReturnValue(args: Dart_NativeArguments, retval: f64);
}

#[doc = " A native function."]
pub type Dart_NativeFunction =
    ::std::option::Option<unsafe extern "C" fn(arguments: Dart_NativeArguments)>;
#[doc = " Native entry resolution callback."]
#[doc = ""]
#[doc = " For libraries and scripts which have native functions, the embedder"]
#[doc = " can provide a native entry resolver. This callback is used to map a"]
#[doc = " name/arity to a Dart_NativeFunction. If no function is found, the"]
#[doc = " callback should return NULL."]
#[doc = ""]
#[doc = " The parameters to the native resolver function are:"]
#[doc = " \\param name a Dart string which is the name of the native function."]
#[doc = " \\param num_of_arguments is the number of arguments expected by the"]
#[doc = "   native function."]
#[doc = " \\param auto_setup_scope is a boolean flag that can be set by the resolver"]
#[doc = "   to indicate if this function needs a Dart API scope (see Dart_EnterScope/"]
#[doc = "   Dart_ExitScope) to be setup automatically by the VM before calling into"]
#[doc = "   the native function. By default most native functions would require this"]
#[doc = "   to be true but some light weight native functions which do not call back"]
#[doc = "   into the VM through the Dart API may not require a Dart scope to be"]
#[doc = "   setup automatically."]
#[doc = ""]
#[doc = " \\return A valid Dart_NativeFunction which resolves to a native entry point"]
#[doc = "   for the native function."]
#[doc = ""]
#[doc = " See Dart_SetNativeResolver."]
pub type Dart_NativeEntryResolver = ::std::option::Option<
    unsafe extern "C" fn(
        name: Dart_Handle,
        num_of_arguments: ::std::os::raw::c_int,
        auto_setup_scope: *mut bool,
    ) -> Dart_NativeFunction,
>;
#[doc = " Native entry symbol lookup callback."]
#[doc = ""]
#[doc = " For libraries and scripts which have native functions, the embedder"]
#[doc = " can provide a callback for mapping a native entry to a symbol. This callback"]
#[doc = " maps a native function entry PC to the native function name. If no native"]
#[doc = " entry symbol can be found, the callback should return NULL."]
#[doc = ""]
#[doc = " The parameters to the native reverse resolver function are:"]
#[doc = " \\param nf A Dart_NativeFunction."]
#[doc = ""]
#[doc = " \\return A const UTF-8 string containing the symbol name or NULL."]
#[doc = ""]
#[doc = " See Dart_SetNativeResolver."]
pub type Dart_NativeEntrySymbol =
    ::std::option::Option<unsafe extern "C" fn(nf: Dart_NativeFunction) -> *const u8>;
#[doc = " An environment lookup callback function."]
#[doc = ""]
#[doc = " \\param name The name of the value to lookup in the environment."]
#[doc = ""]
#[doc = " \\return A valid handle to a string if the name exists in the"]
#[doc = " current environment or Dart_Null() if not."]
pub type Dart_EnvironmentCallback =
    ::std::option::Option<unsafe extern "C" fn(name: Dart_Handle) -> Dart_Handle>;

extern "C" {
    #[doc = " Sets the environment callback for the current isolate. This"]
    #[doc = " callback is used to lookup environment values by name in the"]
    #[doc = " current environment. This enables the embedder to supply values for"]
    #[doc = " the const constructors bool.fromEnvironment, int.fromEnvironment"]
    #[doc = " and String.fromEnvironment."]
    pub fn Dart_SetEnvironmentCallback(callback: Dart_EnvironmentCallback) -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the callback used to resolve native functions for a library."]
    #[doc = ""]
    #[doc = " \\param library A library."]
    #[doc = " \\param resolver A native entry resolver."]
    #[doc = ""]
    #[doc = " \\return A valid handle if the native resolver was set successfully."]
    pub fn Dart_SetNativeResolver(
        library: Dart_Handle,
        resolver: Dart_NativeEntryResolver,
        symbol: Dart_NativeEntrySymbol,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the callback used to resolve native functions for a library."]
    #[doc = ""]
    #[doc = " \\param library A library."]
    #[doc = " \\param resolver a pointer to a Dart_NativeEntryResolver"]
    #[doc = ""]
    #[doc = " \\return A valid handle if the library was found."]
    pub fn Dart_GetNativeResolver(
        library: Dart_Handle,
        resolver: *mut Dart_NativeEntryResolver,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the callback used to resolve native function symbols for a library."]
    #[doc = ""]
    #[doc = " \\param library A library."]
    #[doc = " \\param resolver a pointer to a Dart_NativeEntrySymbol."]
    #[doc = ""]
    #[doc = " \\return A valid handle if the library was found."]
    pub fn Dart_GetNativeSymbol(
        library: Dart_Handle,
        resolver: *mut Dart_NativeEntrySymbol,
    ) -> Dart_Handle;
}

#[repr(i32)]
#[derive(Copy, Clone, Debug, PartialEq, Eq)]
pub enum Dart_LibraryTag {
    CanonicalizeUrl = 0,
    ImportTag = 1,
    KernelTag = 2,
    ImportExtensionTag = 3,
}
#[doc = " The library tag handler is a multi-purpose callback provided by the"]
#[doc = " embedder to the Dart VM. The embedder implements the tag handler to"]
#[doc = " provide the ability to load Dart scripts and imports."]
#[doc = ""]
#[doc = " -- TAGS --"]
#[doc = ""]
#[doc = " Dart_kCanonicalizeUrl"]
#[doc = ""]
#[doc = " This tag indicates that the embedder should canonicalize 'url' with"]
#[doc = " respect to 'library'.  For most embedders, the"]
#[doc = " Dart_DefaultCanonicalizeUrl function is a sufficient implementation"]
#[doc = " of this tag.  The return value should be a string holding the"]
#[doc = " canonicalized url."]
#[doc = ""]
#[doc = " Dart_kImportTag"]
#[doc = ""]
#[doc = " This tag is used to load a library from IsolateMirror.loadUri. The embedder"]
#[doc = " should call Dart_LoadLibraryFromKernel to provide the library to the VM. The"]
#[doc = " return value should be an error or library (the result from"]
#[doc = " Dart_LoadLibraryFromKernel)."]
#[doc = ""]
#[doc = " Dart_kKernelTag"]
#[doc = ""]
#[doc = " This tag is used to load the intermediate file (kernel) generated by"]
#[doc = " the Dart front end. This tag is typically used when a 'hot-reload'"]
#[doc = " of an application is needed and the VM is 'use dart front end' mode."]
#[doc = " The dart front end typically compiles all the scripts, imports and part"]
#[doc = " files into one intermediate file hence we don't use the source/import or"]
#[doc = " script tags. The return value should be an error or a TypedData containing"]
#[doc = " the kernel bytes."]
#[doc = ""]
#[doc = " Dart_kImportExtensionTag"]
#[doc = ""]
#[doc = " This tag is used to load an external import (shared object file). The"]
#[doc = " extension path must have the scheme 'dart-ext:'."]
pub type Dart_LibraryTagHandler = ::std::option::Option<
    unsafe extern "C" fn(
        tag: Dart_LibraryTag,
        library_or_package_map_url: Dart_Handle,
        url: Dart_Handle,
    ) -> Dart_Handle,
>;

extern "C" {
    #[doc = " Sets library tag handler for the current isolate. This handler is"]
    #[doc = " used to handle the various tags encountered while loading libraries"]
    #[doc = " or scripts in the isolate."]
    #[doc = ""]
    #[doc = " \\param handler Handler code to be used for handling the various tags"]
    #[doc = "   encountered while loading libraries or scripts in the isolate."]
    #[doc = ""]
    #[doc = " \\return If no error occurs, the handler is set for the isolate."]
    #[doc = "   Otherwise an error handle is returned."]
    #[doc = ""]
    #[doc = " TODO(turnidge): Document."]
    pub fn Dart_SetLibraryTagHandler(handler: Dart_LibraryTagHandler) -> Dart_Handle;
}

extern "C" {
    #[doc = " Canonicalizes a url with respect to some library."]
    #[doc = ""]
    #[doc = " The url is resolved with respect to the library's url and some url"]
    #[doc = " normalizations are performed."]
    #[doc = ""]
    #[doc = " This canonicalization function should be sufficient for most"]
    #[doc = " embedders to implement the Dart_kCanonicalizeUrl tag."]
    #[doc = ""]
    #[doc = " \\param base_url The base url relative to which the url is"]
    #[doc = "                being resolved."]
    #[doc = " \\param url The url being resolved and canonicalized.  This"]
    #[doc = "            parameter is a string handle."]
    #[doc = ""]
    #[doc = " \\return If no error occurs, a String object is returned.  Otherwise"]
    #[doc = "   an error handle is returned."]
    pub fn Dart_DefaultCanonicalizeUrl(base_url: Dart_Handle, url: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Loads the root library for the current isolate."]
    #[doc = ""]
    #[doc = " Requires there to be no current root library."]
    #[doc = ""]
    #[doc = " \\param buffer A buffer which contains a kernel binary (see"]
    #[doc = "     pkg/kernel/binary.md). Must remain valid until isolate group shutdown."]
    #[doc = " \\param buffer_size Length of the passed in buffer."]
    #[doc = ""]
    #[doc = " \\return A handle to the root library, or an error."]
    pub fn Dart_LoadScriptFromKernel(kernel_buffer: *const u8, kernel_size: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Gets the library for the root script for the current isolate."]
    #[doc = ""]
    #[doc = " If the root script has not yet been set for the current isolate,"]
    #[doc = " this function returns Dart_Null().  This function never returns an"]
    #[doc = " error handle."]
    #[doc = ""]
    #[doc = " \\return Returns the root Library for the current isolate or Dart_Null()."]
    pub fn Dart_RootLibrary() -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the root library for the current isolate."]
    #[doc = ""]
    #[doc = " \\return Returns an error handle if `library` is not a library handle."]
    pub fn Dart_SetRootLibrary(library: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Lookup or instantiate a type by name and type arguments from a Library."]
    #[doc = ""]
    #[doc = " \\param library The library containing the class or interface."]
    #[doc = " \\param class_name The class name for the type."]
    #[doc = " \\param number_of_type_arguments Number of type arguments."]
    #[doc = "   For non parametric types the number of type arguments would be 0."]
    #[doc = " \\param type_arguments Pointer to an array of type arguments."]
    #[doc = "   For non parameteric types a NULL would be passed in for this argument."]
    #[doc = ""]
    #[doc = " \\return If no error occurs, the type is returned."]
    #[doc = "   Otherwise an error handle is returned."]
    pub fn Dart_GetType(
        library: Dart_Handle,
        class_name: Dart_Handle,
        number_of_type_arguments: isize,
        type_arguments: *mut Dart_Handle,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Lookup a class or interface by name from a Library."]
    #[doc = ""]
    #[doc = " \\param library The library containing the class or interface."]
    #[doc = " \\param class_name The name of the class or interface."]
    #[doc = ""]
    #[doc = " \\return If no error occurs, the class or interface is"]
    #[doc = "   returned. Otherwise an error handle is returned."]
    pub fn Dart_GetClass(library: Dart_Handle, class_name: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns an import path to a Library, such as \"file:///test.dart\" or"]
    #[doc = " \"dart:core\"."]
    pub fn Dart_LibraryUrl(library: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a URL from which a Library was loaded."]
    pub fn Dart_LibraryResolvedUrl(library: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " \\return An array of libraries."]
    pub fn Dart_GetLoadedLibraries() -> Dart_Handle;
}

extern "C" {
    pub fn Dart_LookupLibrary(url: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Report an loading error for the library."]
    #[doc = ""]
    #[doc = " \\param library The library that failed to load."]
    #[doc = " \\param error The Dart error instance containing the load error."]
    #[doc = ""]
    #[doc = " \\return If the VM handles the error, the return value is"]
    #[doc = " a null handle. If it doesn't handle the error, the error"]
    #[doc = " object is returned."]
    pub fn Dart_LibraryHandleError(library: Dart_Handle, error: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Called by the embedder to load a partial program. Does not set the root"]
    #[doc = " library."]
    #[doc = ""]
    #[doc = " \\param buffer A buffer which contains a kernel binary (see"]
    #[doc = "     pkg/kernel/binary.md). Must remain valid until isolate shutdown."]
    #[doc = " \\param buffer_size Length of the passed in buffer."]
    #[doc = ""]
    #[doc = " \\return A handle to the main library of the compilation unit, or an error."]
    pub fn Dart_LoadLibraryFromKernel(
        kernel_buffer: *const u8,
        kernel_buffer_size: isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns a flattened list of pairs. The first element in each pair is the"]
    #[doc = " importing library and and the second element is the imported library for each"]
    #[doc = " import in the isolate of a library whose URI's scheme is scheme."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\return A handle to a list of flattened pairs of importer-importee."]
    pub fn Dart_GetImportsOfScheme(scheme: Dart_Handle) -> Dart_Handle;
}

extern "C" {
    #[doc = " Indicates that all outstanding load requests have been satisfied."]
    #[doc = " This finalizes all the new classes loaded and optionally completes"]
    #[doc = " deferred library futures."]
    #[doc = ""]
    #[doc = " Requires there to be a current isolate."]
    #[doc = ""]
    #[doc = " \\param complete_futures Specify true if all deferred library"]
    #[doc = "  futures should be completed, false otherwise."]
    #[doc = ""]
    #[doc = " \\return Success if all classes have been finalized and deferred library"]
    #[doc = "   futures are completed. Otherwise, returns an error."]
    pub fn Dart_FinalizeLoading(complete_futures: bool) -> Dart_Handle;
}

extern "C" {
    #[doc = " Returns the value of peer field of 'object' in 'peer'."]
    #[doc = ""]
    #[doc = " \\param object An object."]
    #[doc = " \\param peer An out parameter that returns the value of the peer"]
    #[doc = "   field."]
    #[doc = ""]
    #[doc = " \\return Returns an error if 'object' is a subtype of Null, num, or"]
    #[doc = "   bool."]
    pub fn Dart_GetPeer(object: Dart_Handle, peer: *mut *mut ::std::os::raw::c_void)
        -> Dart_Handle;
}

extern "C" {
    #[doc = " Sets the value of the peer field of 'object' to the value of"]
    #[doc = " 'peer'."]
    #[doc = ""]
    #[doc = " \\param object An object."]
    #[doc = " \\param peer A value to store in the peer field."]
    #[doc = ""]
    #[doc = " \\return Returns an error if 'object' is a subtype of Null, num, or"]
    #[doc = "   bool."]
    pub fn Dart_SetPeer(object: Dart_Handle, peer: *mut ::std::os::raw::c_void) -> Dart_Handle;
}

pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Unknown:
    Dart_KernelCompilationStatus = -1;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Ok:
    Dart_KernelCompilationStatus = 0;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Error:
    Dart_KernelCompilationStatus = 1;
pub const Dart_KernelCompilationStatus_Dart_KernelCompilationStatus_Crash:
    Dart_KernelCompilationStatus = 2;

#[doc = " Experimental support for Dart to Kernel parser isolate."]
#[doc = ""]
#[doc = " TODO(hausner): Document finalized interface."]
#[doc = ""]
pub type Dart_KernelCompilationStatus = i32;

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_KernelCompilationResult {
    pub status: Dart_KernelCompilationStatus,
    pub error: *mut ::std::os::raw::c_char,
    pub kernel: *mut u8,
    pub kernel_size: isize,
}

extern "C" {
    pub fn Dart_IsKernelIsolate(isolate: Dart_Isolate) -> bool;
}

extern "C" {
    pub fn Dart_KernelIsolateIsRunning() -> bool;
}

extern "C" {
    pub fn Dart_KernelPort() -> Dart_Port;
}

extern "C" {
    pub fn Dart_CompileToKernel(
        script_uri: *const ::std::os::raw::c_char,
        platform_kernel: *const u8,
        platform_kernel_size: isize,
        incremental_compile: bool,
        package_config: *const ::std::os::raw::c_char,
    ) -> Dart_KernelCompilationResult;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_SourceFile {
    pub uri: *const ::std::os::raw::c_char,
    pub source: *const ::std::os::raw::c_char,
}

extern "C" {
    pub fn Dart_CompileSourcesToKernel(
        script_uri: *const ::std::os::raw::c_char,
        platform_kernel: *const u8,
        platform_kernel_size: isize,
        source_files_count: ::std::os::raw::c_int,
        source_files: *mut Dart_SourceFile,
        incremental_compile: bool,
        package_config: *const ::std::os::raw::c_char,
        multiroot_filepaths: *const ::std::os::raw::c_char,
        multiroot_scheme: *const ::std::os::raw::c_char,
    ) -> Dart_KernelCompilationResult;
}

extern "C" {
    pub fn Dart_KernelListDependencies() -> Dart_KernelCompilationResult;
}

extern "C" {
    #[doc = " Sets the kernel buffer which will be used to load Dart SDK sources"]
    #[doc = " dynamically at runtime."]
    #[doc = ""]
    #[doc = " \\param platform_kernel A buffer containing kernel which has sources for the"]
    #[doc = " Dart SDK populated. Note: The VM does not take ownership of this memory."]
    #[doc = ""]
    #[doc = " \\param platform_kernel_size The length of the platform_kernel buffer."]
    pub fn Dart_SetDartLibrarySourcesKernel(
        platform_kernel: *const u8,
        platform_kernel_size: isize,
    );
}

extern "C" {
    #[doc = " Returns true if isolate is the service isolate."]
    #[doc = ""]
    #[doc = " \\param isolate An isolate"]
    #[doc = ""]
    #[doc = " \\return Returns true if 'isolate' is the service isolate."]
    pub fn Dart_IsServiceIsolate(isolate: Dart_Isolate) -> bool;
}

extern "C" {
    #[doc = " Returns the port that script load requests should be sent on."]
    #[doc = ""]
    #[doc = " \\return Returns the port for load requests or ILLEGAL_PORT if the service"]
    #[doc = " isolate failed to startup or does not support load requests."]
    pub fn Dart_ServiceWaitForLoadPort() -> Dart_Port;
}

extern "C" {
    #[doc = " Writes the CPU profile to the timeline as a series of 'instant' events."]
    #[doc = ""]
    #[doc = " Note that this is an expensive operation."]
    #[doc = ""]
    #[doc = " \\param main_port The main port of the Isolate whose profile samples to write."]
    #[doc = " \\param error An optional error, must be free()ed by caller."]
    #[doc = ""]
    #[doc = " \\return Returns true if the profile is successfully written and false"]
    #[doc = "         otherwise."]
    pub fn Dart_WriteProfileToTimeline(
        main_port: Dart_Port,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}

extern "C" {
    #[doc = " Record all functions which have been compiled in the current isolate."]
    #[doc = ""]
    #[doc = " \\param buffer Returns a pointer to a buffer containing the trace."]
    #[doc = "   This buffer is scope allocated and is only valid  until the next call to"]
    #[doc = "   Dart_ExitScope."]
    #[doc = " \\param size Returns the size of the buffer."]
    #[doc = " \\return Returns an valid handle upon success."]
    pub fn Dart_SaveCompilationTrace(
        buffer: *mut *mut u8,
        buffer_length: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Compile all functions from data from Dart_SaveCompilationTrace. Unlike JIT"]
    #[doc = " feedback, this data is fuzzy: loading does not need to happen in the exact"]
    #[doc = " program that was saved, the saver and loader do not need to agree on checked"]
    #[doc = " mode versus production mode or debug/release/product."]
    #[doc = ""]
    #[doc = " \\return Returns an error handle if a compilation error was encountered."]
    pub fn Dart_LoadCompilationTrace(buffer: *mut u8, buffer_length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Record runtime feedback for the current isolate, including type feedback"]
    #[doc = " and usage counters."]
    #[doc = ""]
    #[doc = " \\param buffer Returns a pointer to a buffer containing the trace."]
    #[doc = "   This buffer is scope allocated and is only valid  until the next call to"]
    #[doc = "   Dart_ExitScope."]
    #[doc = " \\param size Returns the size of the buffer."]
    #[doc = " \\return Returns an valid handle upon success."]
    pub fn Dart_SaveTypeFeedback(buffer: *mut *mut u8, buffer_length: *mut isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Compile functions using data from Dart_SaveTypeFeedback. The data must from a"]
    #[doc = " VM with the same version and compiler flags."]
    #[doc = ""]
    #[doc = " \\return Returns an error handle if a compilation error was encountered or a"]
    #[doc = "   version mismatch is detected."]
    pub fn Dart_LoadTypeFeedback(buffer: *mut u8, buffer_length: isize) -> Dart_Handle;
}

extern "C" {
    #[doc = " Compiles all functions reachable from entry points and marks"]
    #[doc = " the isolate to disallow future compilation."]
    #[doc = ""]
    #[doc = " Entry points should be specified using `@pragma(\"vm:entry-point\")`"]
    #[doc = " annotation."]
    #[doc = ""]
    #[doc = " \\return An error handle if a compilation error or runtime error running const"]
    #[doc = " constructors was encountered."]
    pub fn Dart_Precompile() -> Dart_Handle;
}

pub type Dart_StreamingWriteCallback = ::std::option::Option<
    unsafe extern "C" fn(
        callback_data: *mut ::std::os::raw::c_void,
        buffer: *const u8,
        size: isize,
    ),
>;

extern "C" {
    #[doc = "  Creates a precompiled snapshot."]
    #[doc = "   - A root library must have been loaded."]
    #[doc = "   - Dart_Precompile must have been called."]
    #[doc = ""]
    #[doc = "  Outputs an assembly file defining the symbols listed in the definitions"]
    #[doc = "  above."]
    #[doc = ""]
    #[doc = "  The assembly should be compiled as a static or shared library and linked or"]
    #[doc = "  loaded by the embedder. Running this snapshot requires a VM compiled with"]
    #[doc = "  DART_PRECOMPILED_SNAPSHOT. The kDartVmSnapshotData and"]
    #[doc = "  kDartVmSnapshotInstructions should be passed to Dart_Initialize. The"]
    #[doc = "  kDartIsolateSnapshotData and kDartIsolateSnapshotInstructions should be"]
    #[doc = "  passed to Dart_CreateIsolateGroup."]
    #[doc = ""]
    #[doc = "  The callback will be invoked one or more times to provide the assembly code."]
    #[doc = ""]
    #[doc = "  \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppAOTSnapshotAsAssembly(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = "  Creates a precompiled snapshot."]
    #[doc = "   - A root library must have been loaded."]
    #[doc = "   - Dart_Precompile must have been called."]
    #[doc = ""]
    #[doc = "  Outputs an ELF shared library defining the symbols"]
    #[doc = "   - _kDartVmSnapshotData"]
    #[doc = "   - _kDartVmSnapshotInstructions"]
    #[doc = "   - _kDartIsolateSnapshotData"]
    #[doc = "   - _kDartIsolateSnapshotInstructions"]
    #[doc = ""]
    #[doc = "  The shared library should be dynamically loaded by the embedder."]
    #[doc = "  Running this snapshot requires a VM compiled with DART_PRECOMPILED_SNAPSHOT."]
    #[doc = "  The kDartVmSnapshotData and kDartVmSnapshotInstructions should be passed to"]
    #[doc = "  Dart_Initialize. The kDartIsolateSnapshotData and"]
    #[doc = "  kDartIsolateSnapshotInstructions should be passed to Dart_CreateIsolate."]
    #[doc = ""]
    #[doc = "  The callback will be invoked one or more times to provide the binary output."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppAOTSnapshotAsElf(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
        stripped: bool,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = "  Like Dart_CreateAppAOTSnapshotAsAssembly, but only includes"]
    #[doc = "  kDartVmSnapshotData and kDartVmSnapshotInstructions."]
    pub fn Dart_CreateVMAOTSnapshotAsAssembly(
        callback: Dart_StreamingWriteCallback,
        callback_data: *mut ::std::os::raw::c_void,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = "  Same as Dart_CreateAppAOTSnapshotAsAssembly, except all the pieces are"]
    #[doc = "  provided directly as bytes that the embedder can load with mmap. The"]
    #[doc = "  instructions pieces must be loaded with read and execute permissions; the"]
    #[doc = "  other pieces may be loaded as read-only."]
    #[doc = ""]
    #[doc = "  This function has been DEPRECATED. Please use Dart_CreateAppAOTSnapshotAsELF"]
    #[doc = "  or Dart_CreateAppAOTSnapshotAsAssembly instead. A portable ELF loader is"]
    #[doc = "  available in the target //runtime/bin:elf_loader."]
    pub fn Dart_CreateAppAOTSnapshotAsBlobs(
        vm_snapshot_data_buffer: *mut *mut u8,
        vm_snapshot_data_size: *mut isize,
        vm_snapshot_instructions_buffer: *mut *mut u8,
        vm_snapshot_instructions_size: *mut isize,
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        isolate_snapshot_instructions_buffer: *mut *mut u8,
        isolate_snapshot_instructions_size: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Sorts the class-ids in depth first traversal order of the inheritance"]
    #[doc = " tree. This is a costly operation, but it can make method dispatch"]
    #[doc = " more efficient and is done before writing snapshots."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_SortClasses() -> Dart_Handle;
}

extern "C" {
    #[doc = "  Creates a snapshot that caches compiled code and type feedback for faster"]
    #[doc = "  startup and quicker warmup in a subsequent process."]
    #[doc = ""]
    #[doc = "  Outputs a snapshot in two pieces. The pieces should be passed to"]
    #[doc = "  Dart_CreateIsolateGroup in a VM using the same VM snapshot pieces used in the"]
    #[doc = "  current VM. The instructions piece must be loaded with read and execute"]
    #[doc = "  permissions; the data piece may be loaded as read-only."]
    #[doc = ""]
    #[doc = "   - Requires the VM to have not been started with --precompilation."]
    #[doc = "   - Not supported when targeting IA32."]
    #[doc = "   - The VM writing the snapshot and the VM reading the snapshot must be the"]
    #[doc = "     same version, must be built in the same DEBUG/RELEASE/PRODUCT mode, must"]
    #[doc = "     be targeting the same architecture, and must both be in checked mode or"]
    #[doc = "     both in unchecked mode."]
    #[doc = ""]
    #[doc = "  The buffers are scope allocated and are only valid until the next call to"]
    #[doc = "  Dart_ExitScope."]
    #[doc = ""]
    #[doc = " \\return A valid handle if no error occurs during the operation."]
    pub fn Dart_CreateAppJITSnapshotAsBlobs(
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        isolate_snapshot_instructions_buffer: *mut *mut u8,
        isolate_snapshot_instructions_size: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Like Dart_CreateAppJITSnapshotAsBlobs, but also creates a new VM snapshot."]
    pub fn Dart_CreateCoreJITSnapshotAsBlobs(
        vm_snapshot_data_buffer: *mut *mut u8,
        vm_snapshot_data_size: *mut isize,
        vm_snapshot_instructions_buffer: *mut *mut u8,
        vm_snapshot_instructions_size: *mut isize,
        isolate_snapshot_data_buffer: *mut *mut u8,
        isolate_snapshot_data_size: *mut isize,
        isolate_snapshot_instructions_buffer: *mut *mut u8,
        isolate_snapshot_instructions_size: *mut isize,
    ) -> Dart_Handle;
}

extern "C" {
    #[doc = " Get obfuscation map for precompiled code."]
    #[doc = ""]
    #[doc = " Obfuscation map is encoded as a JSON array of pairs (original name,"]
    #[doc = " obfuscated name)."]
    #[doc = ""]
    #[doc = " \\return Returns an error handler if the VM was built in a mode that does not"]
    #[doc = " support obfuscation."]
    pub fn Dart_GetObfuscationMap(buffer: *mut *mut u8, buffer_length: *mut isize) -> Dart_Handle;
}

extern "C" {
    #[doc = "  Returns whether the VM only supports running from precompiled snapshots and"]
    #[doc = "  not from any other kind of snapshot or from source (that is, the VM was"]
    #[doc = "  compiled with DART_PRECOMPILED_RUNTIME)."]
    pub fn Dart_IsPrecompiledRuntime() -> bool;
}

extern "C" {
    #[doc = "  Print a native stack trace. Used for crash handling."]
    #[doc = ""]
    #[doc = "  If context is NULL, prints the current stack trace. Otherwise, context"]
    #[doc = "  should be a CONTEXT* (Windows) or ucontext_t* (POSIX) from a signal handler"]
    #[doc = "  running on the current thread."]
    pub fn Dart_DumpNativeStackTrace(context: *mut ::std::os::raw::c_void);
}

extern "C" {
    #[doc = "  Indicate that the process is about to abort, and the Dart VM should not"]
    #[doc = "  attempt to cleanup resources."]
    pub fn Dart_PrepareToAbort();
}

#[doc = " A Dart_CObject is used for representing Dart objects as native C"]
#[doc = " data outside the Dart heap. These objects are totally detached from"]
#[doc = " the Dart heap. Only a subset of the Dart objects have a"]
#[doc = " representation as a Dart_CObject."]
#[doc = ""]
#[doc = " The string encoding in the 'value.as_string' is UTF-8."]
#[doc = ""]
#[doc = " All the different types from dart:typed_data are exposed as type"]
#[doc = " kTypedData. The specific type from dart:typed_data is in the type"]
#[doc = " field of the as_typed_data structure. The length in the"]
#[doc = " as_typed_data structure is always in bytes."]
#[doc = ""]
#[doc = " The data for kTypedData is copied on message send and ownership remains with"]
#[doc = " the caller. The ownership of data for kExternalTyped is passed to the VM on"]
#[doc = " message send and returned when the VM invokes the"]
#[doc = " Dart_WeakPersistentHandleFinalizer callback; a non-NULL callback must be"]
#[doc = " provided."]
#[repr(i32)]
#[derive(Copy, Clone, PartialEq, Eq)]
pub enum Dart_CObject_Type {
    Null = 0,
    Bool = 1,
    Int32 = 2,
    Int64 = 3,
    Double = 4,
    String = 5,
    Array = 6,
    TypedData = 7,
    ExternalTypedData = 8,
    SendPort = 9,
    Capability = 10,
    Unsupported = 11,
    NumberOfTypes = 12,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub struct Dart_CObject {
    pub type_: Dart_CObject_Type,
    pub value: Dart_CObjectValue,
}

#[repr(C)]
#[derive(Copy, Clone)]
pub union Dart_CObjectValue {
    pub as_bool: bool,
    pub as_int32: i32,
    pub as_int64: i64,
    pub as_double: f64,
    pub as_string: *mut ::std::os::raw::c_char,
    pub as_send_port: Dart_SendPort,
    pub as_capability: Dart_Capability,
    pub as_array: Dart_Array,
    pub as_typed_data: Dart_TypedData,
    pub as_external_typed_data: Dart_ExternalTypedData,
    _bindgen_union_align: [u64; 5usize],
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_SendPort {
    pub id: Dart_Port,
    pub origin_id: Dart_Port,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_Capability {
    pub id: i64,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_Array {
    pub length: isize,
    pub values: *mut *mut Dart_CObject,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_TypedData {
    pub type_: Dart_TypedData_Type,
    pub length: isize,
    pub values: *mut u8,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_ExternalTypedData {
    pub type_: Dart_TypedData_Type,
    pub length: isize,
    pub data: *mut u8,
    pub peer: *mut ::std::os::raw::c_void,
    pub callback: Dart_WeakPersistentHandleFinalizer,
}

extern "C" {
    #[doc = " Posts a message on some port. The message will contain the"]
    #[doc = " Dart_CObject object graph rooted in 'message'."]
    #[doc = ""]
    #[doc = " While the message is being sent the state of the graph of"]
    #[doc = " Dart_CObject structures rooted in 'message' should not be accessed,"]
    #[doc = " as the message generation will make temporary modifications to the"]
    #[doc = " data. When the message has been sent the graph will be fully"]
    #[doc = " restored."]
    #[doc = ""]
    #[doc = " \\param port_id The destination port."]
    #[doc = " \\param message The message to send."]
    #[doc = ""]
    #[doc = " \\return True if the message was posted."]
    pub fn Dart_PostCObject(port_id: Dart_Port, message: *mut Dart_CObject) -> bool;
}

extern "C" {
    #[doc = " Posts a message on some port. The message will contain the integer 'message'."]
    #[doc = ""]
    #[doc = " \\param port_id The destination port."]
    #[doc = " \\param message The message to send."]
    #[doc = ""]
    #[doc = " \\return True if the message was posted."]
    pub fn Dart_PostInteger(port_id: Dart_Port, message: i64) -> bool;
}

#[doc = " A native message handler."]
#[doc = ""]
#[doc = " This handler is associated with a native port by calling"]
#[doc = " Dart_NewNativePort."]
#[doc = ""]
#[doc = " The message received is decoded into the message structure. The"]
#[doc = " lifetime of the message data is controlled by the caller. All the"]
#[doc = " data references from the message are allocated by the caller and"]
#[doc = " will be reclaimed when returning to it."]
pub type Dart_NativeMessageHandler = ::std::option::Option<
    unsafe extern "C" fn(dest_port_id: Dart_Port, message: *mut Dart_CObject),
>;

extern "C" {
    #[doc = " Creates a new native port.  When messages are received on this"]
    #[doc = " native port, then they will be dispatched to the provided native"]
    #[doc = " message handler."]
    #[doc = ""]
    #[doc = " \\param name The name of this port in debugging messages."]
    #[doc = " \\param handler The C handler to run when messages arrive on the port."]
    #[doc = " \\param handle_concurrently Is it okay to process requests on this"]
    #[doc = "                            native port concurrently?"]
    #[doc = ""]
    #[doc = " \\return If successful, returns the port id for the native port.  In"]
    #[doc = "   case of error, returns ILLEGAL_PORT."]
    pub fn Dart_NewNativePort(
        name: *const ::std::os::raw::c_char,
        handler: Dart_NativeMessageHandler,
        handle_concurrently: bool,
    ) -> Dart_Port;
}

extern "C" {
    #[doc = " Closes the native port with the given id."]
    #[doc = ""]
    #[doc = " The port must have been allocated by a call to Dart_NewNativePort."]
    #[doc = ""]
    #[doc = " \\param native_port_id The id of the native port to close."]
    #[doc = ""]
    #[doc = " \\return Returns true if the port was closed successfully."]
    pub fn Dart_CloseNativePort(native_port_id: Dart_Port) -> bool;
}

extern "C" {
    #[doc = " Forces all loaded classes and functions to be compiled eagerly in"]
    #[doc = " the current isolate.."]
    #[doc = ""]
    #[doc = " TODO(turnidge): Document."]
    pub fn Dart_CompileAll() -> Dart_Handle;
}

extern "C" {
    pub fn Dart_ReadAllBytecode() -> Dart_Handle;
}

extern "C" {
    #[doc = " Finalizes all classes."]
    pub fn Dart_FinalizeAllClasses() -> Dart_Handle;
}

extern "C" {
    pub fn Dart_ExecuteInternalCommand(
        command: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> *mut ::std::os::raw::c_void;
}

#[doc = " A service request callback function."]
#[doc = ""]
#[doc = " These callbacks, registered by the embedder, are called when the VM receives"]
#[doc = " a service request it can't handle and the service request command name"]
#[doc = " matches one of the embedder registered handlers."]
#[doc = ""]
#[doc = " The return value of the callback indicates whether the response"]
#[doc = " should be used as a regular result or an error result."]
#[doc = " Specifically, if the callback returns true, a regular JSON-RPC"]
#[doc = " response is built in the following way:"]
#[doc = ""]
#[doc = " {"]
#[doc = "   \"jsonrpc\": \"2.0\","]
#[doc = "   \"result\": <json_object>,"]
#[doc = "   \"id\": <some sequence id>,"]
#[doc = " }"]
#[doc = ""]
#[doc = " If the callback returns false, a JSON-RPC error is built like this:"]
#[doc = ""]
#[doc = " {"]
#[doc = "   \"jsonrpc\": \"2.0\","]
#[doc = "   \"error\": <json_object>,"]
#[doc = "   \"id\": <some sequence id>,"]
#[doc = " }"]
#[doc = ""]
#[doc = " \\param method The rpc method name."]
#[doc = " \\param param_keys Service requests can have key-value pair parameters. The"]
#[doc = "   keys and values are flattened and stored in arrays."]
#[doc = " \\param param_values The values associated with the keys."]
#[doc = " \\param num_params The length of the param_keys and param_values arrays."]
#[doc = " \\param user_data The user_data pointer registered with this handler."]
#[doc = " \\param result A C string containing a valid JSON object. The returned"]
#[doc = "   pointer will be freed by the VM by calling free."]
#[doc = ""]
#[doc = " \\return True if the result is a regular JSON-RPC response, false if the"]
#[doc = "   result is a JSON-RPC error."]
pub type Dart_ServiceRequestCallback = ::std::option::Option<
    unsafe extern "C" fn(
        method: *const ::std::os::raw::c_char,
        param_keys: *mut *const ::std::os::raw::c_char,
        param_values: *mut *const ::std::os::raw::c_char,
        num_params: isize,
        user_data: *mut ::std::os::raw::c_void,
        json_object: *mut *const ::std::os::raw::c_char,
    ) -> bool,
>;

extern "C" {
    #[doc = " Register a Dart_ServiceRequestCallback to be called to handle"]
    #[doc = " requests for the named rpc on a specific isolate. The callback will"]
    #[doc = " be invoked with the current isolate set to the request target."]
    #[doc = ""]
    #[doc = " \\param method The name of the method that this callback is responsible for."]
    #[doc = " \\param callback The callback to invoke."]
    #[doc = " \\param user_data The user data passed to the callback."]
    #[doc = ""]
    #[doc = " NOTE: If multiple callbacks with the same name are registered, only"]
    #[doc = " the last callback registered will be remembered."]
    pub fn Dart_RegisterIsolateServiceRequestCallback(
        method: *const ::std::os::raw::c_char,
        callback: Dart_ServiceRequestCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}

extern "C" {
    #[doc = " Register a Dart_ServiceRequestCallback to be called to handle"]
    #[doc = " requests for the named rpc. The callback will be invoked without a"]
    #[doc = " current isolate."]
    #[doc = ""]
    #[doc = " \\param method The name of the command that this callback is responsible for."]
    #[doc = " \\param callback The callback to invoke."]
    #[doc = " \\param user_data The user data passed to the callback."]
    #[doc = ""]
    #[doc = " NOTE: If multiple callbacks with the same name are registered, only"]
    #[doc = " the last callback registered will be remembered."]
    pub fn Dart_RegisterRootServiceRequestCallback(
        method: *const ::std::os::raw::c_char,
        callback: Dart_ServiceRequestCallback,
        user_data: *mut ::std::os::raw::c_void,
    );
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Dart_EmbedderInformation {
    pub version: i32,
    pub name: *const ::std::os::raw::c_char,
    pub current_rss: i64,
    pub max_rss: i64,
}

#[doc = " Callback provided by the embedder that is used by the vm to request"]
#[doc = " information."]
#[doc = ""]
#[doc = " \\return Returns a pointer to a Dart_EmbedderInformation structure."]
#[doc = " The embedder keeps the ownership of the structure and any field in it."]
#[doc = " The embedder must ensure that the structure will remain valid until the"]
#[doc = " next invokation of the callback."]
pub type Dart_EmbedderInformationCallback =
    ::std::option::Option<unsafe extern "C" fn(info: *mut Dart_EmbedderInformation)>;

extern "C" {
    #[doc = " Register a Dart_ServiceRequestCallback to be called to handle"]
    #[doc = " requests for the named rpc. The callback will be invoked without a"]
    #[doc = " current isolate."]
    #[doc = ""]
    #[doc = " \\param method The name of the command that this callback is responsible for."]
    #[doc = " \\param callback The callback to invoke."]
    #[doc = " \\param user_data The user data passed to the callback."]
    #[doc = ""]
    #[doc = " NOTE: If multiple callbacks with the same name are registered, only"]
    #[doc = " the last callback registered will be remembered."]
    pub fn Dart_SetEmbedderInformationCallback(callback: Dart_EmbedderInformationCallback);
}

extern "C" {
    #[doc = " Invoke a vm-service method and wait for its result."]
    #[doc = ""]
    #[doc = " \\param request_json The utf8-encoded json-rpc request."]
    #[doc = " \\param request_json_length The length of the json-rpc request."]
    #[doc = ""]
    #[doc = " \\param response_json The returned utf8-encoded json response, must be"]
    #[doc = "   free()ed by caller."]
    #[doc = " \\param response_json_length The length of the returned json response."]
    #[doc = " \\param error An optional error, must be free()ed by caller."]
    #[doc = ""]
    #[doc = " \\return Whether the call was sucessfully performed."]
    #[doc = ""]
    #[doc = " NOTE: This method does not need a current isolate and must not have the"]
    #[doc = " vm-isolate being the current isolate. It must be called after"]
    #[doc = " Dart_Initialize() and before Dart_Cleanup()."]
    pub fn Dart_InvokeVMServiceMethod(
        request_json: *mut u8,
        request_json_length: isize,
        response_json: *mut *mut u8,
        response_json_length: *mut isize,
        error: *mut *mut ::std::os::raw::c_char,
    ) -> bool;
}

#[doc = " A callback invoked when the VM service gets a request to listen to"]
#[doc = " some stream."]
#[doc = ""]
#[doc = " \\return Returns true iff the embedder supports the named stream id."]
pub type Dart_ServiceStreamListenCallback =
    ::std::option::Option<unsafe extern "C" fn(stream_id: *const ::std::os::raw::c_char) -> bool>;
#[doc = " A callback invoked when the VM service gets a request to cancel"]
#[doc = " some stream."]
pub type Dart_ServiceStreamCancelCallback =
    ::std::option::Option<unsafe extern "C" fn(stream_id: *const ::std::os::raw::c_char)>;

extern "C" {
    #[doc = " Adds VM service stream callbacks."]
    #[doc = ""]
    #[doc = " \\param listen_callback A function pointer to a listen callback function."]
    #[doc = "   A listen callback function should not be already set when this function"]
    #[doc = "   is called. A NULL value removes the existing listen callback function"]
    #[doc = "   if any."]
    #[doc = ""]
    #[doc = " \\param cancel_callback A function pointer to a cancel callback function."]
    #[doc = "   A cancel callback function should not be already set when this function"]
    #[doc = "   is called. A NULL value removes the existing cancel callback function"]
    #[doc = "   if any."]
    #[doc = ""]
    #[doc = " \\return Success if the callbacks were added.  Otherwise, returns an"]
    #[doc = "   error handle."]
    pub fn Dart_SetServiceStreamCallbacks(
        listen_callback: Dart_ServiceStreamListenCallback,
        cancel_callback: Dart_ServiceStreamCancelCallback,
    ) -> *mut ::std::os::raw::c_char;
}

#[doc = " A callback invoked when the VM service receives an event."]
pub type Dart_NativeStreamConsumer =
    ::std::option::Option<unsafe extern "C" fn(event_json: *const u8, event_json_length: isize)>;

extern "C" {
    #[doc = " Sets the native VM service stream callbacks for a particular stream."]
    #[doc = " Note: The function may be called on multiple threads concurrently."]
    #[doc = ""]
    #[doc = " \\param consumer A function pointer to an event handler callback function."]
    #[doc = "   A NULL value removes the existing listen callback function if any."]
    #[doc = ""]
    #[doc = " \\param stream_id The ID of the stream on which to set the callback."]
    pub fn Dart_SetNativeServiceStreamCallback(
        consumer: Dart_NativeStreamConsumer,
        stream_id: *const ::std::os::raw::c_char,
    );
}

extern "C" {
    #[doc = " Sends a data event to clients of the VM Service."]
    #[doc = ""]
    #[doc = " A data event is used to pass an array of bytes to subscribed VM"]
    #[doc = " Service clients.  For example, in the standalone embedder, this is"]
    #[doc = " function used to provide WriteEvents on the Stdout and Stderr"]
    #[doc = " streams."]
    #[doc = ""]
    #[doc = " If the embedder passes in a stream id for which no client is"]
    #[doc = " subscribed, then the event is ignored."]
    #[doc = ""]
    #[doc = " \\param stream_id The id of the stream on which to post the event."]
    #[doc = ""]
    #[doc = " \\param event_kind A string identifying what kind of event this is."]
    #[doc = "   For example, 'WriteEvent'."]
    #[doc = ""]
    #[doc = " \\param bytes A pointer to an array of bytes."]
    #[doc = ""]
    #[doc = " \\param bytes_length The length of the byte array."]
    #[doc = ""]
    #[doc = " \\return Success if the arguments are well formed.  Otherwise, returns an"]
    #[doc = "   error handle."]
    pub fn Dart_ServiceSendDataEvent(
        stream_id: *const ::std::os::raw::c_char,
        event_kind: *const ::std::os::raw::c_char,
        bytes: *const u8,
        bytes_length: isize,
    ) -> Dart_Handle;
}

#[doc = " A callback which determines whether the file at some url has been"]
#[doc = " modified since some time.  If the file cannot be found, true should"]
#[doc = " be returned."]
pub type Dart_FileModifiedCallback = ::std::option::Option<
    unsafe extern "C" fn(url: *const ::std::os::raw::c_char, since: i64) -> bool,
>;

extern "C" {
    pub fn Dart_SetFileModifiedCallback(
        file_modified_callback: Dart_FileModifiedCallback,
    ) -> *mut ::std::os::raw::c_char;
}

extern "C" {
    #[doc = " Returns true if isolate is currently reloading."]
    pub fn Dart_IsReloading() -> bool;
}

extern "C" {
    #[doc = " Returns a timestamp in microseconds. This timestamp is suitable for"]
    #[doc = " passing into the timeline system, and uses the same monotonic clock"]
    #[doc = " as dart:developer's Timeline.now."]
    #[doc = ""]
    #[doc = " \\return A timestamp that can be passed to the timeline system."]
    pub fn Dart_TimelineGetMicros() -> i64;
}

extern "C" {
    #[doc = " Start recording timeline events for the entire VM (including all isolates)."]
    #[doc = ""]
    #[doc = " \\param stream_mask A bitmask of streams that should be recorded."]
    #[doc = ""]
    #[doc = " NOTE: Calling with 0 disables recording of all streams."]
    pub fn Dart_GlobalTimelineSetRecordedStreams(stream_mask: i64);
}

#[repr(i32)]
#[derive(Clone, Copy, PartialEq, Eq)]
pub enum Dart_Timeline_Event_Type {
    Begin = 0,
    End = 1,
    Instant = 2,
    Duration = 3,
    Async_Begin = 4,
    Async_End = 5,
    Async_Instant = 6,
    Counter = 7,
    Flow_Begin = 8,
    Flow_Step = 9,
    Flow_End = 10,
}

extern "C" {
    #[doc = " Add a timeline event to the embedder stream."]
    #[doc = ""]
    #[doc = " \\param label The name of the event. Its lifetime must extend at least until"]
    #[doc = "     Dart_Cleanup."]
    #[doc = " \\param timestamp0 The first timestamp of the event."]
    #[doc = " \\param timestamp1_or_async_id The second timestamp of the event or"]
    #[doc = "     the async id."]
    #[doc = " \\param argument_count The number of argument names and values."]
    #[doc = " \\param argument_names An array of names of the arguments. The lifetime of the"]
    #[doc = "     names must extend at least until Dart_Cleanup. The array may be reclaimed"]
    #[doc = "     when this call returns."]
    #[doc = " \\param argument_values An array of values of the arguments. The values and"]
    #[doc = "     the array may be reclaimed when this call returns."]
    pub fn Dart_TimelineEvent(
        label: *const ::std::os::raw::c_char,
        timestamp0: i64,
        timestamp1_or_async_id: i64,
        type_: Dart_Timeline_Event_Type,
        argument_count: isize,
        argument_names: *mut *const ::std::os::raw::c_char,
        argument_values: *mut *const ::std::os::raw::c_char,
    );
}

extern "C" {
    #[doc = " Associates a name with the current thread. This name will be used to name"]
    #[doc = " threads in the timeline. Can only be called after a call to Dart_Initialize."]
    #[doc = ""]
    #[doc = " \\param name The name of the thread."]
    pub fn Dart_SetThreadName(name: *const ::std::os::raw::c_char);
}

extern "C" {
    #[doc = " Return metrics gathered for the VM and individual isolates."]
    #[doc = ""]
    #[doc = " NOTE: Metrics are not available in PRODUCT builds of Dart."]
    #[doc = " Calling the metric functions on a PRODUCT build might return invalid metrics."]
    pub fn Dart_VMIsolateCountMetric() -> i64;
}

extern "C" {
    pub fn Dart_VMCurrentRSSMetric() -> i64;
}

extern "C" {
    pub fn Dart_VMPeakRSSMetric() -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapOldUsedMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapOldUsedMaxMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapOldCapacityMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapOldCapacityMaxMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapOldExternalMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapNewUsedMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapNewUsedMaxMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapNewCapacityMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapNewCapacityMaxMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapNewExternalMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapGlobalUsedMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateHeapGlobalUsedMaxMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateRunnableLatencyMetric(isolate: Dart_Isolate) -> i64;
}

extern "C" {
    pub fn Dart_IsolateRunnableHeapSizeMetric(isolate: Dart_Isolate) -> i64;
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_locale_data {
    pub _address: u8,
}

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __crt_multibyte_data {
    pub _address: u8,
}
