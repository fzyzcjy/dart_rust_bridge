// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

import 'package:logging/logging.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'dart:io';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These types are ignored because they are not used by any `pub` functions: `DartLoggingLevel`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `enabled`, `flush`, `from`, `from`, `from`, `from`, `log`

Future<int> minimalAdder({required int a, required int b}) =>
    RustLib.instance.api.crateApiMinimalMinimalAdder(a: a, b: b);

Stream<Log2DartLogRecord> initializeLog2Dart({required Level maxLogLevel}) =>
    RustLib.instance.api
        .crateApiMinimalInitializeLog2Dart(maxLogLevel: maxLogLevel);

class FRBLogger {
  final RustStreamSink<Log2DartLogRecord> streamSink;

  const FRBLogger({
    required this.streamSink,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FRBLogger> newInstance() =>
      RustLib.instance.api.crateApiMinimalFrbLoggerNew();

  static void _default_log_function(Log2DartLogRecord record) {
    print(
        '${DateTime.now()} [${log_level_from_number(record.levelNumber)} @${record.rustLog ? 'Rust' : 'Dart'}]: ${record.loggerName} \n   ${record.message}');
  }

  static Logger init_logger(
      {String name = 'RootLogger',
      Level maxLoglevel = Level.INFO,
      Function(Log2DartLogRecord) custom_log_function =
          _default_log_function}) {
    String? env_log_level = Platform.environment['LOG_LEVEL'];
    if (env_log_level != null) {
      print(
          'Taking log level from env: ${env_log_level} instead of the one given by code: ${maxLoglevel}');
      maxLoglevel = _log_level_from_str(env_log_level);
    }

    Log2DartLogRecord _toLog2DartLogRecord(LogRecord record) {
      return Log2DartLogRecord(
          levelNumber: record.level.value,
          message: record.message,
          loggerName: record.loggerName,
          rustLog: false,
          modulePath: null,
          fileName: null,
          lineNumber: null);
    }

    final logger = Logger(name);

    Logger.root.level = maxLoglevel;

    var stream = initializeLog2Dart(maxLogLevel: maxLoglevel);
    // logs from Rust
    stream.listen((record) {
      // custom_log_function(_toLogRecord(record));
      custom_log_function(record);
    });

    // logs from Dart
    Logger.root.onRecord.listen((record) {
      custom_log_function(_toLog2DartLogRecord(record));
    });

    return logger;
  }

  static Level _log_level_from_str(String levelStr) {
    switch (levelStr.toUpperCase()) {
      case 'ALL':
        return Level.ALL;
      case 'FINEST':
        return Level.FINEST;
      case 'FINER':
        return Level.FINER;
      case 'FINE':
        return Level.FINE;
      case 'CONFIG':
        return Level.CONFIG;
      case 'INFO':
        return Level.INFO;
      case 'WARNING':
        return Level.WARNING;
      case 'SEVERE':
        return Level.SEVERE;
      case 'SHOUT':
        return Level.SHOUT;
      case 'OFF':
        return Level.OFF;
      default:
        print(
            'unknown LOG_LEVEL: ${levelStr}. For potential values see https://pub.dev/documentation/logging/latest/logging/Level-class.html');
        exit(1);
    }
  }

// convert from log level number to Dart package logging->Level
  static Level log_level_from_number(int level) {
    switch (level) {
      case <= 500:
        return Level.ALL;
      case <= 700:
        return Level.CONFIG;
      case <= 800:
        return Level.INFO;
      case <= 900:
        return Level.WARNING;
      case < 2000:
        return Level.SEVERE;
      case >= 2000:
        return Level.OFF;
      default:
        return Level.ALL;
    }
  }

  @override
  int get hashCode => streamSink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FRBLogger &&
          runtimeType == other.runtimeType &&
          streamSink == other.streamSink;
}

class Log2DartLogRecord {
  final int levelNumber;
  final String message;
  final String loggerName;
  final bool rustLog;
  final String? modulePath;
  final String? fileName;
  final int? lineNumber;

  const Log2DartLogRecord({
    required this.levelNumber,
    required this.message,
    required this.loggerName,
    required this.rustLog,
    this.modulePath,
    this.fileName,
    this.lineNumber,
  });

  @override
  int get hashCode =>
      levelNumber.hashCode ^
      message.hashCode ^
      loggerName.hashCode ^
      rustLog.hashCode ^
      modulePath.hashCode ^
      fileName.hashCode ^
      lineNumber.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Log2DartLogRecord &&
          runtimeType == other.runtimeType &&
          levelNumber == other.levelNumber &&
          message == other.message &&
          loggerName == other.loggerName &&
          rustLog == other.rustLog &&
          modulePath == other.modulePath &&
          fileName == other.fileName &&
          lineNumber == other.lineNumber;
}
