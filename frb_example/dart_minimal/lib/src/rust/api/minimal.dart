// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

import 'package:logging/logging.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `enabled`, `flush`, `from`, `log`

Future<int> minimalAdder({required int a, required int b}) =>
    RustLib.instance.api.crateApiMinimalMinimalAdder(a: a, b: b);

Stream<Log2DartLogRecord> initializeLog2Dart({required Level maxLogLevel}) =>
    RustLib.instance.api
        .crateApiMinimalInitializeLog2Dart(maxLogLevel: maxLogLevel);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Log2DartLogRecord>>
abstract class Log2DartLogRecord implements RustOpaqueInterface {
  Level get level;

  String get loggerName;

  String get message;

  set level(Level level);

  set loggerName(String loggerName);

  set message(String message);
}

class FRBLogger {
  final RustStreamSink<Log2DartLogRecord> streamSink;

  const FRBLogger({
    required this.streamSink,
  });

  static Future<void> setupLogging() =>
      RustLib.instance.api.crateApiMinimalFrbLoggerSetupLogging();

  static void default_log_function(LogRecord record) {
    print('${record.level}:${record.loggerName}: ${record.message}');
  }

  static Function(LogRecord) _logFunction = default_log_function;

  static Logger init_logger(
      {String name = 'RootLogger',
      Level maxLoglevel = Level.INFO,
      Function(LogRecord) custom_log_function = default_log_function}) {
    LogRecord _toLogRecord(Log2DartLogRecord record) {
      return LogRecord(
        record.level,
        record.message,
        record.loggerName,
      );
    }

    _logFunction = custom_log_function;

    final logger = Logger(name);

    Logger.root.level = maxLoglevel;

    var stream = initializeLog2Dart(maxLogLevel: maxLoglevel);
    // logs from Rust
    stream.listen((record) {
      _logFunction(_toLogRecord(record));
    });

    // logs from Dart
    Logger.root.onRecord.listen((record) {
      _logFunction(record);
    });

    return logger;
  }

// convert from log crate's LevelFilter to Dart package logging->Level
  static Level fromLevelFilter(int level) {
    switch (level) {
      case <= 500:
        return Level.ALL;
      case <= 700:
        return Level.CONFIG;
      case <= 800:
        return Level.INFO;
      case <= 900:
        return Level.WARNING;
      case < 2000:
        return Level.SEVERE;
      case >= 2000:
        return Level.OFF;
      default:
        return Level.ALL;
    }
  }

// convert from log crate's Record to Dart package logging->LogRecord
// extension syntax is not supported by frb
// extension ToLogRecord on Log2DartLogRecord {
//   LogRecord toLogRecord(Log2DartLogRecord record) {
//     return LogRecord(
//       record.level,
//       record.message,
//       record.loggerName,
//     );
//   }
// }

// extension SetLogMethod on Logger {
  void setLogFunction(Function(LogRecord) custom_log_function) {
    _logFunction = custom_log_function;
  }
// }

  @override
  int get hashCode => streamSink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FRBLogger &&
          runtimeType == other.runtimeType &&
          streamSink == other.streamSink;
}
