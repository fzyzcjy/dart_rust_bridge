// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.4.0.

import 'package:logging/logging.dart';

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../frb_generated.dart';
import 'dart:io';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `enabled`, `flush`, `from`, `log`

Future<int> minimalAdder({required int a, required int b}) =>
    RustLib.instance.api.crateApiMinimalMinimalAdder(a: a, b: b);

Stream<Log2DartLogRecord> initializeLog2Dart({required Level maxLogLevel}) =>
    RustLib.instance.api
        .crateApiMinimalInitializeLog2Dart(maxLogLevel: maxLogLevel);

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Log2DartLogRecord>>
abstract class Log2DartLogRecord implements RustOpaqueInterface {
  Level get level;

  String get loggerName;

  String get message;

  set level(Level level);

  set loggerName(String loggerName);

  set message(String message);
}

class FRBLogger {
  final RustStreamSink<Log2DartLogRecord> streamSink;

  const FRBLogger({
    required this.streamSink,
  });

  // HINT: Make it `#[frb(sync)]` to let it become the default constructor of Dart class.
  static Future<FRBLogger> newInstance() =>
      RustLib.instance.api.crateApiMinimalFrbLoggerNew();

  static void _default_log_function(LogRecord record) {
    print('${record.level}:${record.loggerName}: ${record.message}');
  }

  static Logger init_logger(
      {String name = 'RootLogger',
      Level maxLoglevel = Level.INFO,
      Function(LogRecord) custom_log_function = _default_log_function}) {
    String? env_log_level = Platform.environment['LOG_LEVEL'];
    if (env_log_level != null) {
      print(
          'Taking log level from env: ${env_log_level} instead of the one given by code: ${maxLoglevel}');
      maxLoglevel = _log_level_from_str(env_log_level);
    }

    LogRecord _toLogRecord(Log2DartLogRecord record) {
      return LogRecord(
        record.level,
        record.message,
        record.loggerName,
      );
    }

    final logger = Logger(name);

    Logger.root.level = maxLoglevel;

    var stream = initializeLog2Dart(maxLogLevel: maxLoglevel);
    // logs from Rust
    stream.listen((record) {
      custom_log_function(_toLogRecord(record));
    });

    // logs from Dart
    Logger.root.onRecord.listen((record) {
      custom_log_function(record);
    });

    return logger;
  }

  static Level _log_level_from_str(String levelStr) {
    switch (levelStr.toUpperCase()) {
      case 'ALL':
        return Level.ALL;
      case 'FINEST':
        return Level.FINEST;
      case 'FINER':
        return Level.FINER;
      case 'FINE':
        return Level.FINE;
      case 'CONFIG':
        return Level.CONFIG;
      case 'INFO':
        return Level.INFO;
      case 'WARNING':
        return Level.WARNING;
      case 'SEVERE':
        return Level.SEVERE;
      case 'SHOUT':
        return Level.SHOUT;
      case 'OFF':
        return Level.OFF;
      default:
        print(
            'unknown LOG_LEVEL: ${levelStr}. For potential values see https://pub.dev/documentation/logging/latest/logging/Level-class.html');
        exit(1);
    }
  }

// convert from log crate's LevelFilter to Dart package logging->Level
  static Level fromLevelFilter(int level) {
    switch (level) {
      case <= 500:
        return Level.ALL;
      case <= 700:
        return Level.CONFIG;
      case <= 800:
        return Level.INFO;
      case <= 900:
        return Level.WARNING;
      case < 2000:
        return Level.SEVERE;
      case >= 2000:
        return Level.OFF;
      default:
        return Level.ALL;
    }
  }

  @override
  int get hashCode => streamSink.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FRBLogger &&
          runtimeType == other.runtimeType &&
          streamSink == other.streamSink;
}
